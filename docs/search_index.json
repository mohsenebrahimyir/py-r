[["index.html", "پایتون و آر مفاهیم پایه برای برنامه نویسی با زبان‌های Python و R پیش گفتار", " پایتون و آر مفاهیم پایه برای برنامه نویسی با زبان‌های Python و R محبوبه کاتبی باشگاه مغز محسن ابراهیمی باشگاه مغز مهر ۱۴۰۰ پیش گفتار به همراه این کتاب می‌توانید یادگیری فیزیک را شروع کنید. سعی کنید بعد از هر آموزش تمرینات مربوط به آن را انجام دهید. نظرات و پیشنهادات خود را می‌توانید از طریق ایمیل mhb.s.katebi@gmail.com و mohsenebrahimy.ir@gmail.com برای بهبود کتاب به نویسنده ارسال کنید تا در هر بروزرسانی اصلاحات صورت گیرد. این نسخه در تاریخ 1401-2-13 بروزرسانی شده است. https://mohsenebrahimyir.github.io/py-r/ امیدوارم این کتاب برایتان مفید باشد. نویسندگان کتاب "],["intro.html", "مقدمه", " مقدمه این کتاب از روی کتاب‌های پایتون برای همه (Severance, Blumenberg, and Hauser 2016) و آر برای تحلیلگر داده (Wickham and Grolemund 2017) تهیه شده است. باقی محتوا از منیع اینترنتی آزاد گرفته شده و یا توسط نویسندگان تولید شده‌اند. بنابراین کپی برداری با ذکر منبع آزاد می‌باشد. منابع "],["why-learn-python.html", "فصل 1 چرایی یادگیری پایتون", " فصل 1 چرایی یادگیری پایتون شاید دلیل ما برای شروع یادگیری پایتون این باشد که ن یاز به آنالیز داده‌های زیادی داریم، یا برای امرار معاش به این راه وارد شده‌ایم. همچنین اگر در حوزه علم داده (Data Science) و یا هوش مصنوعی (Artificial Intelligence) مشغول به فعالیت هستیم، زبان برنامه‌نویسی پایتون، گزینه بسیار مناسبی برای ما خواهد بود. در نهایت اینکه ممکن است به یکی از دلایل زیر، ما نیاز به یادگیری پایتون داشته باشیم: 1- اسکریپت و اتوماسیون در پایتون 2- استفاده از پایتون برای داده‌های بزرگ (Big Data) 3- پشتیبانی پایتون از تست (Testing) 4- گرافیک کامپیوتری در پایتون 5- استفاده از پایتون در توسعه وب 6- سازگار و قابل انتقال بودن 7- تفسیر داده‌های تصویربرداری عصبی 8- بهره‌مندی از پایتون در طراحی Task در نرم‌افزارهایی مانند Psychopy "],["computer-hardware-architect.html", "1.1 معماری سخت‌افزار کامپیوتر", " 1.1 معماری سخت‌افزار کامپیوتر اگر ما در ابتدای ورود به مسیر برنامه‌نویسی هستیم، بهتر است کمی درمورد اینکه کامپیوتر چگونه کار می‌کند، صحبت کنیم. خوب است بدانیم، قسمت‌های مختلف یک کامپیوتر به زبان بسیار ساده، به این ترتیب هستند: تعاریف سطح بالای این قطعات به شرح زیر است: پردازنده مرکزی یا Central Processing Unit (CPU): می‌تواند در هر ثانیه چندین کار را انجام دهد طوری که ما احساس کنیم کارها بطور موازی انجام می‌شوند. اینکه چه تعداد کار را در یک ثانیه انجام دهد، به سرعت پردازنده ما بستگی دارد. بطور مثال، اگر سرعت پردازنده ما 3.0 گیگاهرتز (3.0 Gigahertz) باشد، به معنی این است که به تعداد سه میلیارد کار در هر ثانیه، می‌تواند انجام دهد. حافظه اصلی یا Main Memory: برای ذخیره و دردسترس قرار دادن اطلاعات ضروری و مورد نیاز سریع پردازنده مرکزی، بکار می‌رود. اما باید مراقب اطلاعات خود در حافظه اصلی باشیم، چرا که با خاموش شدن کامپیوتر و یا راه‌اندازی مجدد (restart) اطلاعات آن از بین می‌رود. حافظه ثانویه یا (Secondary Memory): این نوع حافظه برای ذخیره دائمی اطلاعات بکارمی‌رود، اما سرعت آن از سرعت حافظه اصلی کمتر است. دستگاه‌های ورودی و خروجی یا (Input and Output Devices): همان وسایلی هستند که به کمک آن‌ها با کامپیوتر ارتباط برقرار می‌کنیم، شامل صفحه کلید، مانیتور، ماوس و … و ما به عنوان یک برنامه‌نویس مسئول این هستیم که به CPU بگوئیم چه زمانی چه کاری انجام دهد و از کدام دستگاه‌های ورودی و خروجی استفاده کند. به این ترتیب، ما همه این منابع را باهم هماهنگ می‌سازیم. "],["understanding-programming.html", "1.2 درک برنامه‌نویسی", " 1.2 درک برنامه‌نویسی برای اینکه بتوانیم مهارت خوبی در برنامه‌نویسی بدست آوریم، دو نکته را در نظر داشته باشیم: اول اینکه باید با زبان برنامه‌نویسی موردنظر خود آشنا شویم یعنی لغات رزرو شده (Reserved Words) و گرامر زبان برنامه‌نویسی خوب است بدانیم برای هر زبان برنامه‌نویسی، لغاتی هستند که مفهوم خاصی داشته و کاربر برنامه‌نویس نمی‌تواند از آن‌ها برای منظور و کاربرد دیگری استفاده نماید. درعین حال، هر برنامه‌نویسی می‌تواند لغات خاص منظوره خود را به مفسر زبان برنامه‌نویسی خود معرفی کند. یکی از روش‌های انجام این کار، تعریف متغیر (Variable) است. کلمات رزرو شده توسط پایتون، شامل موارد ذیل می‌شوند: and as assert break class continue def del elif else except finally for from global if in is import lambda nonlocal not or pass raise return try while with yield دوم اینکه، بتوانیم یک داستان بگوئیم! در واقع هنر حل مسئله، اصلی‌ترین مهارت یک برنامه‌نویس محسوب می‌شود. با کسب این مهارت، می‌توانیم زبان‌های برنامه‌نویسی دوم به بعد را راحت‌تر بیاموزیم. پس برای شروع، ما شروع به خواندن و توضیح برنامه‌ها می‌کنیم، آنگاه برنامه‌های ساده‌ می نویسیم، و سپس برنامه‌های پیچیده‌تر را در طول زمان می‌نویسیم. اگر خوب پیش برویم، خواهیم توانست روش و یا الگوریتم حل مسئله را از دیدگاه خودمان بنویسیم و آنگاه به مرور، مهارت حل خلاقانه مسئله را بدست خواهیم آورد. "],["interpreter-and-compiler.html", "1.3 مترجم و کامپایلر", " 1.3 مترجم و کامپایلر پایتون یک زبان سطح بالا محسوب می‌شود. به این معنی که به زبان انسان نزدیک‌تر است تا به زبان سخت‌افزار کامپیوتر. اما مفهوم دستورات زبان‌های سطح بالا توسط CPU قابل فهم نیست. چرا که CPU فقط دستوراتی که به زبان ماشین نوشته شده باشند را درک می‌کند. زبان ماشین از دو نشانه 0 و 1 تشکیل شده است و CPU قادر است تنها همین زبان را بفهمد و دستورات آن را اجرا کند: 00101000111010010010101000000111 11100110000011101010010101101101 ... پس برنامه‌های زبان‌های سطح بالایی مثل پایتون را چگونه باید برای CPU شرح داد؟ مترجم‌های متعددی برای ترجمه و تبدیل کدهای زبان سطح بالا به زبان سطح ماشین، وجود دارد. اما از آن‌جایی که زبان ماشین کاملا وابسته به سخت‌افزار کامپیوتر است، بنابراین ما یک زبان ماشین که بتواند با انواع سخت‌افزار هماهنگ شود را نداریم. برنامه‌های نوشته شده به زبان‌های سطح بالا را می‌توان با استفاده از یک مفسر متفاوت در ماشین (همان سخت‌افزار) جدید یا کامپایل مجدد کد برای ایجاد نسخه زبان ماشین برنامه موردنظر برای ماشین جدید بین رایانه های مختلف جابجا کرد. این مترجمان زبان برنامه‌نویسی به دو دسته کلی تقسیم می شوند: مفسر (Interpreter) کامپایلر (Compiler) یک مفسر کد برنامه نوشته شده توسط برنامه‌نویس را خوانده، آن را تجزیه می‌کند و دستورالعمل‌ها را تفسیر می‌نماید. با این توصیف، پایتون یک مفسر محسوب می‌شود که کدهای برنامه ما رافوراً پردازش می‌کند. برخی دستورات پایتون شامل مقادیری است که مجدداً دراثنای برنامه، برنامه‌نویس به آن نیاز خواهد داشت. بنابراین ما به عنوان برنامه‌نویس می‌بایست یک نام نمادین برای این مقادیر تعریف کنیم که در وقت لازم با این نام تعریف شده، پایتون را متوجه استفاده از آن مقدار موردنظر گردانیم. واژه‌ای که برای این نام مخصوص استفاده می‌شود، Variable یا متغیر است: x = 6 print(x) 6 y = x * 7 print(y) 42 در این مثال ساده، ما سعی کردیم به پایتون بگوییم در ابتدا برای مقدار 6، برچسبی به نام x در نظر بگیرد و سپس در دستور بعدی همین مقدار را با نام x بازیابی کردیم. آنگاه آن را در 7 ضرب کرده و حاصل آن را در متغیر جدیدی با نام y ذخیره کردیم. دو خط مربوط به تابع print مقادیر x و y صرفاً برای مشاهده مقادیر ذخیره شده در متغیرهای بکار رفته در پرانتز می‌باشد. "],["variables-expressions-commands.html", "فصل 2 متغیرها، عبارات و دستورات ", " فصل 2 متغیرها، عبارات و دستورات "],["boolean-expressions.html", "2.1 عبارات بولی", " 2.1 عبارات بولی عبارت بولی (Boolean expressions) عبارتی است که یا درست یا نادرست است. عملگر== برای مقایسه دو عملوند بکار می‌رود و نتیجه آن درستی (True) یا نادرستی (False) نتیجه این ارزیابی را نشان می‌دهد: 5 == 5 True 5 == 6 False عملگر == یکی از عملگرهای مقایسه‌ای است، سایر عملگرها عبارتند از: x != y # x is not equal to y x &gt; y # x is greater than y x &lt; y # x is less than y x &gt;= y # x is greater than or equal to y x &lt;= y # x is less than or equal to y x is y # x is the same as y x is not y # x is not the same as y "],["logical-operators.html", "2.2 عملگرهای منطقی", " 2.2 عملگرهای منطقی سه عملگر منطقی (Logical Operators) وجود دارد: and, or و not . برای مثال: x &gt; 0 and x &lt; 10 عملوندهای عملگرهای منطقی باید عبارات بولی باشند، اما در پایتون هر عدد غیر صفر نیز به صورت True تفسیر می‌شود. 17 and True True "],["condition-statement.html", "فصل 3 اجرای شرطی ", " فصل 3 اجرای شرطی "],["condition-execution.html", "3.1 اجرای شرطی", " 3.1 اجرای شرطی برای نوشتن یک برنامه کارآ، خیلی اوقات نیاز به بررسی شرایط مختلف داریم که براساس آن‌ها رفتارهای متفاوتی را طراحی کنیم. با استفاده از جملات شرطی (Conditional Statements) می‌توانیم این قابلیت را بدست آوریم. if x &gt; 0 : print(&#39;x is positive&#39;) عبارت منطقی پس از if ، شرط یا (condition) نامیده می‌شود. اگر شرط منطقی درست باشد، دستور تورفتگی اجرا می‌شود. اگر شرط منطقی نادرست باشد، عبارت تورفتگی نادیده گرفته می‌شود. "],["alternative-execution.html", "3.2 اجرای جایگزین", " 3.2 اجرای جایگزین شکل دوم یک عبارت if اجرای جایگزین (Alternative Execution) است که در آن دو حالت ممکن توسط شرط بررسی می‌شود که کدامیک می‌بایست اجرا شوند: if x%2 == 0 : print(&#39;x is even&#39;) else : print(&#39;x is odd&#39;) ز آنجایی که شرط باید درست یا نادرست باشد، دقیقاً یکی از گزینه‌ها اجرا می‌شود. گزینه‌های جایگزین شاخه (Branch) نامیده می‌شوند، زیرا آنها شاخه‌هایی در جریان اجرا هستند. "],["chained-conditionals.html", "3.3 شرط‌های زنجیره‌ای", " 3.3 شرط‌های زنجیره‌ای یکی از راه‌های بررسی بیش از سه شرط این است که با استفاده از elif از شرط‌های زنجیری (Chained Conditionals) استفاده کنیم: if x &lt; y: print(&#39;x is less than y&#39;) elif x &gt; y: print(&#39;x is greater than y&#39;) else: print(&#39;x and y are equal&#39;) "],["nested-conditionals.html", "3.4 شرط‌های تو در تو", " 3.4 شرط‌های تو در تو یک عبارت شرطی نیز می‌تواند درون عبارت شرطی دیگری قرار گیرد و ساختار شرط‌های تو در تو (Nested Conditionals) را ایجاد کنند: if x == y: print(&#39;x and y are equal&#39;) else: if x &lt; y: print(&#39;x is less than y&#39;) else: print(&#39;x is greater than y&#39;) "],["try-except-statement.html", "3.5 استفاده از try و except", " 3.5 استفاده از try و except برخی اوقات در جریان برنامه‌نویسی شرطی، نیاز داریم که به مفسر پایتون بگوئیم براساس ورودی‌های مختلف چگونه رفتار کند تا کد برنامه ما با خطا رویرو نشود. مثلاً در برنامه از کاربر خواستیم مقداری عددی وارد کند و بر اساس این مقدار، قرار است محاسبه‌ای انجام گیرد. حال فرض کنید کاربر مقداری غیر عددی وارد کرد و آنگاه این مقدار غیرعددی در یک فرمول محاسباتی وارد می‌شود! چه اتفاقی می‌افتد؟ مفسر پایتون اجرای برنامه را قطع می‌کند، چرا که نتوانسته است مقدار غیرعددی را در محاسبات وارد کند. در این مواقع استفاده از ساختار try-except می‌تواند کمک‌کننده باشد: inp = input(&#39;Enter Fahrenheit Temperature:&#39;) try: fahr = float(inp) cel = (fahr - 32.0) * 5.0 / 9.0 print(cel) except: print(&#39;Please enter a number&#39;) در اینجا پایتون کار را با اجرای دستور try آغاز می‌کند و اگر همه چیز خوب باشد، بلاک except را درنظر نمی‌گیرد. اما اگر استثنایی در بلاک try رخ داد، مفسر پایتون از بلاک try عبور می‌کند و به اجرای بلاک except می‌پردازد. "],["functions.html", "فصل 4 توابع ", " فصل 4 توابع "],["import-function.html", "4.1 فراخوانی تابع", " 4.1 فراخوانی تابع در حوزه برنامه‌نویسی، یک تابع دنباله‌ای از جملات است که یک محاسبات را انجام می‌دهد. درواقع ما با تعیین یک نام و یک سری دستورات، می‌توانیم یک تابع را تعریف کنیم و آنگاه با صداکردن نام آن تابع، خواهیم توانست آن را فراخوانی کنیم. بسیاری از دستوراتی را که تابحال از آن‌ها استفاده می‌کردیم، درواقع تابع بودند: type(32) &lt;class &#39;int&#39;&gt; که در این جا نام تابع type است. "],["built-in-functions.html", "4.2 توابع داخلی", " 4.2 توابع داخلی توابع داخلی (Built-in) این‌ها توابعی هستند که توسط سازندگان پایتون تعبیه شده‌اند و برای حل مسائل عمومی مورد استفاده قرار می‌گیرند. نمونه‌ای از این توابع عبارتند از: max(&#39;Hello world&#39;) &#39;w&#39; min(&#39;Hello world&#39;) &#39; &#39; len(&#39;Hello world&#39;) 11 "],["type-conversion-functions.html", "4.3 توابع تبدیل نوع", " 4.3 توابع تبدیل نوع توابع تبدیل نوع (Type Conversion) این‌ها نوع دیگری از توابع داخلی هستند که مقدار یک نوع را به نوعی دیگر تبدیل می‌کنند: int(3.99999) 3 int(-2.3) -3 float(&#39;3.14159&#39;) 3.14159 "],["math-functions.html", "4.4 توابع ریاضی", " 4.4 توابع ریاضی پایتون دارای یک ماژول ریاضی است که اکثر توابع ریاضی مشهور را ارائه می‌دهد. اما قبل از اینکه بتوانیم از ماژول استفاده کنیم، باید آن را وارد (import) کنیم: import math این عبارت یک شی ماژول به نام math ایجاد می کند. برای دسترسی به یکی از توابع، باید نام ماژول و نام تابع را که با یک نقطه از هم جدا شده اند (که به عنوان نقطه نیز شناخته می شود) مشخص کنیم. به این فرمت، علامت نقطه می گویند. ratio = signal_power / noise_power decibels = 10 * math.log10(ratio) radians = 0.7 height = math.sin(radians) "],["random-numbers.html", "4.5 اعداد تصادفی", " 4.5 اعداد تصادفی به نظر می‌رسد که ساختن یک برنامه واقعاً غیر قطعی چندان آسان نیست، اما راه‌هایی وجود دارد که حداقل غیرقطعی به نظر برسد. یکی از آنها استفاده از الگوریتم‌هایی است که اعداد شبه تصادفی (Random) تولید می‌کنند. درست است که اعداد شبه تصادفی واقعاْ تصادفی نیستند اما بازهم تمایز آن‌ها از اعداد تصادفیُ غیرممکن است. ماژول random توابعی را بدست می‌دهد که اعداد تصادفی تولید می‌کنند. یک مثال را باهم ببینیم: import random for i in range(10): x = random.random() print(x) 0.0920530236235576 0.6250171315179012 0.7706549349232131 0.7402147110407385 0.15988207593735793 0.4024047009691475 0.8179640452074257 0.44502244153994786 0.8980030614870437 0.9357510761663985 این برنامه یک لیستی از اعداد تصادفی بین 0 و 1 تولید می‌کند که شامل 1 نمی‌شوند: مثال‌هایی دیگر از توابع random‌ عبارتند از: random.randint(5, 10) 7 t = [1, 2, 3] random.choice(t) 3 "],["create-new-function.html", "4.6 افزودن یک تابع جدید", " 4.6 افزودن یک تابع جدید ما معمولاْ برای پیشبرد اهداف برنامه موردنظرمان، نیاز به تعریف توابع جدید خواهیم داشت. این توابع در آینده بارها و بارها می‌توانند مورد استفاده قرار گیرند. در مثال زیر، یک تابع به نام print_lyrics تعریف می‌کنیم: def print_lyrics(): print(&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;) print(&#39;I sleep all night and I work all day.&#39;) همانطور که در این مثال می‌بینید، کلمه کلیدی def برای تعریف تابع بکار برده می‌شود. با تعریف یک تابع، یک متغیر با همان نام ایجاد می‌شود. نحو فراخوانی تابع جدید مانند توابع داخلی است: print_lyrics() I&#39;m a lumberjack, and I&#39;m okay. I sleep all night and I work all day. ما حتی می‌توانیم یک تابع تعریف شده را درون تابع دیگر، فراخوانی کنیم. "],["parameters-and-arguments.html", "4.7 پارامترها و آرگومان‌ها", " 4.7 پارامترها و آرگومان‌ها برخی از توابع داخلی که دیده‌ایم به آرگومان نیاز دارند. برای مثال، وقتی تابع math.sin را فراخوانی می‌کنیم، باید یک عدد را به آن بدهیم. به این ورودی، آرگومان (Argument) گفته می‌شود. "],["fruitful-functions-and-void-functions.html", "4.8 توابع دارای خروجی و توابع بدون خروجی", " 4.8 توابع دارای خروجی و توابع بدون خروجی در اجرای برخی توابع، با اتمام آخرین دستور تابع، مقداری را به عنوان نتیجه در خروجی می‌بینیم. این توابع را Fruitful می‌نامند: import math math.sqrt(5) 2.23606797749979 اما این اتفاق برای همه توابع رخ نمی‌دهد. درواقع این توابع کاری را انجام داده‌اند که بصورت خروجی قابل نمایش نیست. این توابع را Void می‌نامند: def No_reult_func (): x = math.cos(radians) "],["iteration.html", "فصل 5 تکرار", " فصل 5 تکرار برای جلوگیری از دویاره نویسی در برنامه‌ها از ساختار حلقه (Loop) یا تکرار (Iteration) می‌وان استفاده کرد. "],["while-iteration.html", "5.1 عبارت while", " 5.1 عبارت while برای شروع آشنایی با عبارت و در حقیقت ساختار while به مثال زیر توجه کنید: n = 5 while n &gt; 0: print(n) n = n - 1 print(&#39;Blastoff!&#39;) 5 4 3 2 1 Blastoff! به این معنی که “تا وقتی که n بزرگتر از 0 است، مقدار n را نمایش بده و سپس مقدار n را به اندازه 1 واحد کاهش بده. وقتی مقدار n به 0 رسید، کنترل برنامه از دستور while خارج می‌شود و کلمه Blastoff را نمایش می‌دهد! ساختار استفاده از عبارت while به شرح زیر است: شرایط را ارزیابی کنید، درست یا غلط را نشان دهید. اگر شرط نادرست است، از دستور while خارج شده و در دستور بعدی اجرا را ادامه دهید. اگر شرط درست است، بدنه را اجرا کنید و سپس به مرحله 1 برگردید. این نوع جریان حلقه نامیده می‌شود زیرا در مرحله سوم به سمت بالا باز می‌گردد. هر بار که بدنه حلقه را اجرا می‌کنیم، آن را یک تکرار می‌نامیم. برای حلقه بالا، می‌گوییم: «پنج تکرار داشت»، یعنی بدنه حلقه پنج بار اجرا شده است. بدنه حلقه باید مقدار یک یا چند متغیر را تغییر دهد تا در نهایت شرط نادرست شود و حلقه خاتمه یابد. ما متغیری را که هر بار که حلقه اجرا می‌شود و مقدار متغیر تغییر می‌کند، فراخوانی می‌کنیم و نیز زمانی که حلقه، مقدار متغیر تکرار را به پایان می‌رساند، اگر متغیر تکراری وجود نداشته باشد، حلقه برای همیشه تکرار می‌شود و در نتیجه یک حلقه بی نهایت ایجاد می‌شود. "],["infinite-loops.html", "5.2 حلقه‌های بی‌نهایت", " 5.2 حلقه‌های بی‌نهایت در مورد شمارش معکوس، می‌توانیم ثابت کنیم که حلقه خاتمه می‌یابد زیرا می‌دانیم که مقدار n محدود است و می‌بینیم که مقدار n هر بار از طریق حلقه کوچکتر می‌شود، بنابراین در نهایت باید به 0 برسیم. در سایر مواقع، یک حلقه بی‌نهایت Infinite loops است زیرا هیچ متغیر تکراری ندارد (به شبه شرط منطقی داخل پرانتز در عبارت break دقت کنید). کاربرد حلقه بی‌نهایت در این است که برخی اوقات تا زمانی که نیمی از بدنه را طی نکنیم، نمی‌دانیم آیا زمان پایان دادن به یک حلقه فرا رسیده است. در این صورت می‌توانیم یک حلقه بی‌نهایت را عمداً بنویسیم و سپس از دستور break برای پرش از حلقه استفاده کنیم. n = 10 while True: print(n, end=&#39; &#39;) n = n - 1 print(&#39;Done!&#39;) اگر مرتکب اشتباه شویم و این کد را اجرا کنیم، یاد خواهیم گرفت که چگونه فرآیند و یا مسیر پایتون را در سیستم خود متوقف کنیم و یا آن را خاتمه دهیم. این برنامه برای همیشه یا تا زمانی که باتری ما تمام شود اجرا می‌شود زیرا عبارت منطقی در بالای حلقه به دلیل این که عبارت مقدار ثابت True است همیشه درست است. مثال زیر، کاربرد break را به خوبی نشان می‌دهد: while True: line = input(&#39;&gt; &#39;) if line == &#39;done&#39;: break print(line) print(&#39;Done!&#39;) "],["continue-iteration.html", "5.3 اتمام تکرار فعلی و ادامه تکرار بعدی", " 5.3 اتمام تکرار فعلی و ادامه تکرار بعدی گاهی اوقات ما در یک تکرار یک حلقه هستیم و می‌خواهیم تکرار فعلی را تمام کنیم و بلافاصله به تکرار بعدی برویم. در آن صورت می‌توانیم از دستور continue برای پرش به تکرار بعدی استفاده کنیم، بدون اینکه بدنه حلقه برای تکرار فعلی تمام شود. while True: line = input(&#39;&gt; &#39;) if line[0] == &#39;#&#39;: continue if line == &#39;done&#39;: break print(line) print(&#39;Done!&#39;) "],["for-iteration.html", "5.4 حلقه‌های معین با استفاده از", " 5.4 حلقه‌های معین با استفاده از گاهی اوقات می‌خواهیم مجموعه‌ای از چیزها را مانند فهرستی از کلمات، خطوط یک فایل یا فهرستی از اعداد را بصورت حلقه‌ای ایجاد کنیم. وقتی لیستی از چیزهایی که باید از طریق آنها حلقه بزنیم داریم، می توانیم با استفاده از دستور for یک حلقه معین بسازیم. دستور while را یک حلقه نامعین می نامیم زیرا به سادگی حلقه می‌زند تا زمانی که برخی از شرط‌ها False شود، در حالی که حلقه for در مجموعه‌ای شناخته شده از آیتم‌ها حلقه می‌زند بنابراین به تعداد آیتم‌های مجموعه، تکرار می‌شود. friends = [&#39;Joseph&#39;, &#39;Glenn&#39;, &#39;Sally&#39;] for friend in friends: print(&#39;Happy New Year: &#39;, friend) print(&#39;Done!&#39;) Happy New Year: Joseph Happy New Year: Glenn Happy New Year: Sally Done! "],["string.html", "فصل 6 رشته‌ها ", " فصل 6 رشته‌ها "],["string-length.html", "6.1 محاسبه طول متن", " 6.1 محاسبه طول متن len یک تابع داخلی در پایتون است که تعداد کاراکترهای یک رشته را برمی‌گرداند. fruit = &#39;banana&#39; length = len(fruit) حال اگر این عدد را به عنوان اندیس متغیر رشته استفاده کنیم، آخرین کاراکتر رشته را بدست می‌آوریم: last = fruit[length - 1] print(last) a دلیل این تفریق این است که شماره اندیس اولین کاراکتر رشته، با صفر شروع می‌شود. بنابراین برای دستیابی به موقعیت‌های دیگر یک رشته، می‌توان اندیس‌ها را تغییر داد: fruit = &#39;banana&#39; fruit[:3] ana "],["immutable-string.html", "6.2 رشته‌ها تغییرناپذیرند", " 6.2 رشته‌ها تغییرناپذیرند درعین حال اینکه می‌توان به همه کاراکترهای یک رشته دست پیدا کرد، اما نمی‌توان کاراکتر دیگری را جایگزین یکی از کاراکترهای رشته کرد: greeting = &#39;Hello, world!&#39; greeting[0] = &#39;J&#39; اگر این دستور را اجرا کنید، با خطا مواجه می‌شوید، چراکه رشته‌ها قابل تغییر نیستند. "],["in-operation.html", "6.3 عملگر in", " 6.3 عملگر in گاربرد این عملگر زمانی است که می‌خواهیم بدانیم آیا یک رشته حاوی یک رشته و یا کاراکتر خاصی هست یا خیر: &#39;a&#39; in &#39;banana&#39; و یا این حالت: &#39;seed&#39; in &#39;banana&#39; همچنین با استفاده از عملگرهای &lt; و &gt; می‌توانیم رشته‌ها را از نظر ترتیب حروف الفبا با یکدیگر مقایسه کنیم: if word &lt; &#39;banana&#39;: print(&#39;Your word,&#39; + word + &#39;, comes before banana.&#39;) elif word &gt; &#39;banana&#39;: print(&#39;Your word,&#39; + word + &#39;, comes after banana.&#39;) else: print(&#39;All right, bananas.&#39;) "],["string-methods.html", "6.4 متدهای رشته‌ای", " 6.4 متدهای رشته‌ای ] پایتون تابعی به نام dir دارد که متدهای مربوط به یک شیئ را لیست می‌کند و همچنین با استفاده از type می‌توانیم نوع شیئ را تشخیص دهیم: stuff = &#39;Hello world&#39; type(stuff) &lt;class &#39;str&#39;&gt; dir(stuff) [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;] روش دیگر برای یافتن موقعیت یک زیررشته و یا یک کاراکتر خاص در یک رشته اصلی، استفاده از متد [find]{dir-ltr} می‌باشد: word = &#39;banana&#39; index = word.find(&#39;a&#39;) print(index) 1 خوب است با متدهای strip و startwith و lower برای آشنایی بیشتر با متدهای رشته‌ای، در برنامه پایتون خودمان تمرین کنیم. "],["format-operator.html", "6.5 عملگر فرمت", " 6.5 عملگر فرمت عملگر format %، به ما اجازه می‌دهد تا رشته‌ها را بسازیم و بخش‌هایی از رشته‌ها را با داده‌های ذخیره شده در متغیرها جایگزین کنیم: camels = 42 &#39;%d&#39; % camels &#39;42&#39; در مثال بالا توانستیم حروف 4 و 2 را به عدد 42 تبدیل کنیم. d مخفف “اعشاری” است. و یا این مثال: camels = 42 &#39;I have spotted %d camels.&#39; % camels &#39;I have spotted 42 camels.&#39; به همین ترتیب، عملگرهای %g و %s وظیفه قالب‌بندی یک عدد ممیز شناور و قالب‌بندی یک رشته را به عهده دارند: fmt_string = &#39;In %d years I have spotted %g %s.&#39; % (3, 0.1, &#39;camels&#39;) print(fmt_string) &#39;In 3 years I have spotted 0.1 camels.&#39; یک شکل جدید از قالب رشته‌ای در نسخه‌های جدید پایتون استفاده از f'' یا همان f-string است. age = 27 name = &quot;Mohsen&quot; text = f&quot;Mr {name} is {age} years old.&quot; print(text) Mr Mohsen is 27 years old. "],["files.html", "فصل 7 فایل‌ها ", " فصل 7 فایل‌ها "],["open-file.html", "7.1 بازکردن فایل", " 7.1 بازکردن فایل ممکن است داده‌های ما از قبل در فایلی موجود باشد (دانلود فایل) ، در اینصورت باید بتوانیم آن را باز کنیم: fhand = open(&#39;mbox.txt&#39;) print(fhand) &lt;_io.TextIOWrapper name=&#39;mbox.txt&#39; mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&gt; اگر باز کردن موفقیت‌آمیز باشد، سیستم‌عامل یک handle برای فایل به ما برمی‌گرداند. handle، داده‌های واقعی موجود در فایل نیست، اما در عوض یک handle است که می‌توانیم برای خواندن داده‌ها از آن استفاده کنیم. اگر فایل درخواستی وجود داشته باشد و مجوزهای لازم برای خواندن فایل را داشته باشیم، به ما یک handle داده می شود. اما چنانچه فایل وجود نداشته باشد، اجرای این دستور ناموفق خواهد بود و handle نخواهیم داشت: Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; FileNotFoundError: [Errno 2] No such file or directory: &#39;mbox.txt&#39; "],["read-file.html", "7.2 خواندن فایل", " 7.2 خواندن فایل با بازکردن فایل، تنها یک handle در اختیار خواهیم داشت تا بتوانیم با استفاده از آن با فایل موردنظر کار کنیم. بنابریان برای خواندن فایل، می‌بایست با یک دستور حلقه for ساده، اقدام به خواندن فایل کنیم: fhand = open(&#39;mbox.txt&#39;) count = 0 for line in fhand: count = count + 1 print(&#39;Line Count:&#39;, count) Line Count: 7 با این دستورات، ما سعی کرده‌ایم که فایل را خط به خط بخوانیم. اما این طریقه خواندن برای فایل‌های بزرگ مورد استفاده قرار می‌گیرد. اگر فایلی داشته باشیم و بدانیم حجم آن کم است، می‌توانیم از دستورات زیر استفاده کنیم: fhand = open(&#39;mbox.txt&#39;) inp = fhand.read() print(len(inp)) 334 print(inp[:20]) From stephen.marquar در این حالت بهتر است رشته خوانده شده از فایل را در یک متغیر ذخیره کنیم، چراکه با خواندن فایل بعدی به همین روش، محتویات فایل قبلی را از دست خواهیم داد، به همین دلیل ما از متغیر inp در دستورات فوق استفاده کردیم. "],["search-in-file.html", "7.3 جستجو در فایل", " 7.3 جستجو در فایل اگر در فایل محتویات داده به دنبال کلمه و یا داده خاصی هستیم، می‌توانیم آن را در فایلی که از قبل آن را باز کرده و خوانده‌ایم، جستجو کنیم: fhand = open(&#39;mbox.txt&#39;) count = 0 for line in fhand: line = line.rstrip() if line.startswith(&#39;From:&#39;): print(line) From: stephen.marquard@uct.ac.za در این مثال، ما به دنبال کلمه 'From' هستیم. ما با استفاده از تابع rstrip() فضای خالی را در سمت راست رشته موجود در فایل، حذف کرده‌ایم. "],["select-file.html", "7.4 انتخاب نام فایل", " 7.4 انتخاب نام فایل این مسئله برای ما پیش آمده که برای باز کردن یک فایل، همیشه نام و آدرس دقیق آن را نمی‌دانیم و نیاز است تا بتوانیم در مرورگر سیستم فایل خود، آن را جستجو کنیم. به این منظور، با استفاده از قطعه کد زیر، این امکان را به کاربر می‌دهیم که فایل موردنظر خود را ابتدا جستجو و سپس باز کند. در اینصورت ما دیگر نام فایل را بصورت مستقیم در کد خود نخواهیم داشت: fname = input(&#39;Enter the file name: &#39;) fhand = open(fname) count = 0 for line in fhand: if line.startswith(&#39;Subject:&#39;): count = count + 1 print(&#39;There were&#39;, count, &#39;subject lines in&#39;, fname) Enter the file name: mbox.txt There were 1 subject lines in mbox.txt "],["try-except-open-file.html", "7.5 استفاده از try، except و open", " 7.5 استفاده از try، except و open از کد قبل به خاطر داریم که ما به کاربر اجازه دادیم که نام فایل حود را برای بازکردن، انتخاب نماید. حال اگر کاربر ما چیزی را تایپ کند که نام فایل نیست چه؟ بنابراین باید تمهیداتی برای این کار بیاندیشیم، چرا که گذشته از اینکه بازکردن یک فایل غیرمرتبط برنامه را با خطا مواجه می‌کند، ممکن است فایلی که کاربر آن را انتخاب کرده، عمداً و یا سهواً برای برنامه ما ضرر داشته باشد. بنابراین ما با استفاده از دستورات try ، except و open این اتفاق را مدیریت می‌کنیم: fname = input(&#39;Enter the file name: &#39;) try: fhand = open(fname) except: print(&#39;File cannot be opened:&#39;, fname) exit() count = 0 for line in fhand: if line.startswith(&#39;Subject:&#39;): count = count + 1 print(&#39;There were&#39;, count, &#39;subject lines in&#39;, fname) Enter the file name: otherfile.txt File cannot be opened: otherfile.txt There were 0 subject lines in otherfile.txt همانطور که مشاهده می‌شود، تابع exit() درصورت اینکه کاربر چیزی غیر از فایل را درخواست داده باشد، برنامه ما از اجرا خارج می‌شود. "],["write-file.html", "7.6 نوشتن در فایل", " 7.6 نوشتن در فایل بیشتر اوقات افراد نیاز دارند که در فایل داده خود، ویرایش انجام داده یا داده جدیدی به آن بیافزایند. بنابراین باید قادر باشند که با استفاده از دستورات لازم، این کار را انجام دهند. اما یک نکته متفاوت اینجا مطرح می‌شود، به این قطعه کد توجه کنید: fout = open(&#39;output.txt&#39;, &#39;w&#39;) print(fout) &lt;_io.TextIOWrapper name=&#39;output.txt&#39; mode=&#39;w&#39; encoding=&#39;UTF-8&#39;&gt; در اینجا چنانچه فایل موردنظر وجود داشته باشد، فایل باز شده و آماده نوشتن می‌باشد: در واقع پارمتر ‘w’ این اجازه را صادر می‌کند. اما اگر فایل موجود نباشد، یک فایل جدید با نام ذکر شده، ایجاد می‌شود و آماده نوشتن خواهد بود. مثلاً فرض کنیم می‌خواهیم متن زیر را در فایل بنویسیم: This here&#39;s the wattle کد لازم برای این کار، به شکل زیر خواهد بود: line1 = &quot;This here&#39;s the wattle,\\n&quot; fout.write(line1) 24 و درنهایت اینکه وقتی کارمان با فایلی تمام شد، می‌بایست حتماً آن را ببندیم: fout.close() "],["lists.html", "فصل 8 لیست‌ها ", " فصل 8 لیست‌ها "],["a-list-is-a-sequence.html", "8.1 لیست یک دنباله است", " 8.1 لیست یک دنباله است برای کنارهم قرار دادن چندین داده با نوع مختلف، می‌توان از لیست استفاده کرد. یکی از راه‌های ایجاد لیست، بکاربردن براکت در تعریف آن است: cheeses = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] numbers = [17, 123] empty = [] print(cheeses, numbers, empty) [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] [17, 123] [] اما همانطور که گفته بودیم، عناصر لیست می‌توانند نوع‌های متفاوت از هم داشته باشند: multi_types_items = [&#39;spam&#39;, 2.0, 5, [10, 20]] در دو مثال قبلی؛ تعداد عناصر لیست را به این شکل محاسبه می‌کنیم: لیست cheeses دارای 3 عنصر است. لیست numbers دو عنصر دارد و لیست multi_types_items شامل 4 عنصر می‌شود. چراکه لیست داخلی که شامل عناصر 10 و 20 هست، در لیست اصلی، به عنوان یک عنصر و یا داده درنظرگرفته می‌شود. برای تغییر مقادیر موجود در لیست، می‌بایست بتوانیم به هر داده دسترسی داشته باشیم، به این منظور از اندیس برای آدرس‌دهی استفاده می‌کنیم: numbers = [17, 123] numbers[1] = 5 print(numbers) [17, 5] و یا برای اینکه بدانیم داده مورد نظر ما در لیست قرار گرفته یا خیر، می‌توان از این روش استفاده کرد: cheeses = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] &#39;Edam&#39; in cheeses True و یا: cheeses = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] &#39;Brie&#39; in cheeses False "],["traversing-a-list.html", "8.2 پیمایش در لیست", " 8.2 پیمایش در لیست مواقعی هست که می‌خواهیم کل یک لیست را پیمایش کنیم و داده‌های آن را در یک عملیات محاسبه‌ای و یا هرنوع عملیات دیگر، وارد سازیم، در اینصورت: for cheese in cheeses: print(cheese) Cheddar Edam Gouda این کار بسیار ساده بود. چرا که ما تمام لیست را یکی یکی پیمایش کردیم و آن را در خروجی چاپ کردیم. اما اگر نیاز داشته باشیم که در حین پیمایش، داده‌ای از لیست را تغییر دهیم، چه روشی را باید درپیش بگیریم؟ for i in range(len(numbers)): numbers[i] = numbers[i] * 2 "],["work-with-list-items.html", "8.3 کارکردن با عناصر لیست", " 8.3 کارکردن با عناصر لیست در قطعه کد زیر، به ترتیب با استفاده از عملگرهای + و * آشنا می‌شویم و سپس نحوه برش‌های مختلف لیست را یادمی‌گیریم: a = [1, 2, 3] b = [4, 5, 6] c = a + b print(c) [1, 2, 3, 4, 5, 6] [1, 2, 3] * 3 [1, 2, 3, 1, 2, 3, 1, 2, 3] t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] t[1:3] [&#39;b&#39;, &#39;c&#39;] t[:4] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] t[3:] [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;] "],["list-methods.html", "8.4 متدهای لیست", " 8.4 متدهای لیست برای اضافه کردن یک عنصر به انتهای لیست، می‌توانیم از متد append() استفاده کنیم: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] t.append(&#39;d&#39;) print(t) [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] همچنین متد extend() یک لیست را به عنوان آرگومان ورودی دریافت می‌کند و آن را به انتهای لیست معرفی شده، اضافه می‌کند: t1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] t2 = [&#39;d&#39;, &#39;e&#39;] t1.extend(t2) print(t1) [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] برای مرتب کردن عناصر یک لیست، متد sort() در اختیار ماست: t = [&#39;d&#39;, &#39;c&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;] t.sort() print(t) [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] اگر چنانچه خواسته باشیم عنصری را از داخل یک لیست حذف کنیم، با دانستن اندیس موقعیت آن عنصر، می‌توانیم از متد ‘pop(i)’ استفاده کنیم: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] x = t.pop(1) print(t) [&#39;a&#39;, &#39;c&#39;] print(x) b اگر در استفاده از دستور pop() اندیس استفاده نشود، این متد، آخرین عنصر آرایه را حذف خواهد کرد. به کد زیر و نتیجه اجرای آن دقت کنید: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] del t[1] print(t) [&#39;a&#39;, &#39;c&#39;] به نظر شما تفاوت استفاده از متدهای pop(i) و del list_name[i] در چیست؟ بله، درست است که هر دو باعث حذف یک عنصر از لیست می‌شوند اما در استفاده از متد pop(i) عنصر حذف شده در اختیار ما خواهد بود. به این معنی که خروجی این متد، نمایانگر مقدار عنصر حذف شده است. اما در استفاده از دستور del list_name[i] عنصری که حذف شده دیگر در دسترس ما نخواهد بود. حال به این سوال فکر کنید که اگر اندیس عنصر موردنظر برای حذف کردن را ندانیم، از چه روشی می‌توانیم آن عنصر خاص را حذف کنیم؟ درواقع پایتون برای این منظور متد remove(item_value) را پیشنهاد می‌دهد که با ارسال مقدار عنصر موردنظر به عنوان آرگومان ورودی به این متد، می‌توانیم آن را از لیست حذف کنیم: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] t.remove(&#39;b&#39;) print(t) [&#39;a&#39;, &#39;c&#39;] و یا برای حذف بیش از یک مقدار، با دانستن اندیس آن‌ها می‌توان از روش زیر استفاده کرد: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] del t[1:5] print(t) [&#39;a&#39;, &#39;f&#39;] "],["important-function-for-lists.html", "8.5 برخی توابع مهم مربوط به لیست", " 8.5 برخی توابع مهم مربوط به لیست در کدهای زیر نام و کاربرد برخی توابع مهم برای استفاده در لیست‌ها معرفی شده‌اند: nums = [3, 41, 12, 9, 74, 15] print(len(nums)) 6 print(max(nums)) 74 print(min(nums)) 3 print(sum(nums)) 154 print(sum(nums)/len(nums)) 25.666666666666668 "],["lists-strings.html", "8.6 لیست‌ها و رشته‌ها", " 8.6 لیست‌ها و رشته‌ها یک رشته، دنباله‌ای از کاراکترهاست و یک لیست دنباله‌ای از عناصر. اما یک لیست از کاراکترها، همانند یک رشته نیست. برای تبدیل یک رشته به یک لیست، می‌توان از متد یا تابع list(string_name) استفاده کرد: s = &#39;spam&#39; t = list(s) print(t) [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;m&#39;] اما اگر بخواهیم رشته‌ای از کلمات را به لیست تبدیل کنیم، چه باید کرد: s = &#39;pining for the fjords&#39; t = s.split() print(t) [&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;] و یا مثالی دیگر که در آن با کاربرد توابع split(delimiter) و join(list_name) آشنا می‌شویم: s = &#39;spam-spam-spam&#39; delimiter = &#39;-&#39; s.split(delimiter) [&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] t = [&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;] delimiter = &#39; &#39; delimiter.join(t) &#39;pining for the fjords&#39; "],["r-programming-language.html", "فصل 9 زبان برنامه نویسی آر", " فصل 9 زبان برنامه نویسی آر یه ویرایش ساده "],["appandix.html", "ضمیمه", " ضمیمه "],["references.html", "منابع", " منابع "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
