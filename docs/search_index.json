[["index.html", "پایتون و آر مفاهیم پایه برای برنامه نویسی با زبان‌های Python و R پیش گفتار", " پایتون و آر مفاهیم پایه برای برنامه نویسی با زبان‌های Python و R محبوبه کاتبی باشگاه مغز محسن ابراهیمی باشگاه مغز مهر ۱۴۰۰ پیش گفتار به همراه این کتاب می‌توانید یادگیری فیزیک را شروع کنید. سعی کنید بعد از هر آموزش تمرینات مربوط به آن را انجام دهید. نظرات و پیشنهادات خود را می‌توانید از طریق ایمیل mhb.s.katebi@gmail.com و mohsenebrahimy.ir@gmail.com برای بهبود کتاب به نویسنده ارسال کنید تا در هر بروزرسانی اصلاحات صورت گیرد. این نسخه در تاریخ 1401-2-12 بروزرسانی شده است. https://mohsenebrahimyir.github.io/py-r/ امیدوارم این کتاب برایتان مفید باشد. نویسندگان کتاب "],["intro.html", "مقدمه", " مقدمه این کتاب از روی کتاب‌های پایتون برای همه (Severance, Blumenberg, and Hauser 2016) و آر برای تحلیلگر داده (Wickham and Grolemund 2017) تهیه شده است. باقی محتوا از منیع اینترنتی آزاد گرفته شده و یا توسط نویسندگان تولید شده‌اند. بنابراین کپی برداری با ذکر منبع آزاد می‌باشد. References "],["ضمیمه.html", "ضمیمه", " ضمیمه "],["references.html", "منابع", " منابع "],["بخش-اول-چرایی-یادگیری-پایتون.html", "فصل 1 بخش اول: چرایی یادگیری پایتون", " فصل 1 بخش اول: چرایی یادگیری پایتون شاید دلیل ما برای شروع یادگیری پایتون این باشد که نیاز به آنالیز داده‌های زیادی داریم، یا برای امرار معاش به این راه وارد شده‌ایم. همچنین اگردر حوزه علم داده (Data Science) و یا هوش مصنوعی (Artificial Intelligence) مشغول به فعالیت هستیم، زبان برنامه‌نویسی پایتون، گزینه بسیار مناسبی برای ما خواهد بود. و در نهایت اینکه ممکن است به یکی از دلایل زیر، ما نیاز به یادگیری پایتون داشته باشیم: 1- اسکریپت و اتوماسیون در پایتون 2- استفاده از پایتون برای داده‌های بزرگ 3- پشتیبانی پایتون از تست (Testing) 4- گرافیک کامپیوتری در پایتون 5- استفاده از پایتون در توسعه وب 6- سازگار و قابل انتقال بودن 7- تفسیر داده‌های تصویربرداری عصبی 8- بهره‌مندی از پایتون در طراحی Task در نرم‌افزارهایی مانند Psychopy "],["معماری-سختافزار-کامپیوتر.html", "1.1 معماری سخت‌افزار کامپیوتر", " 1.1 معماری سخت‌افزار کامپیوتر اگر ما در ابتدای ورود به مسیر برنامه‌نویسی هستیم، بهتر است کمی درمورد اینکه کامپیوتر چگونه کار می‌کند، صحبت کنیم. خوب است بدانیم، قسمت‌های مختلف یک کامپیوتر به زبان بسیار ساده، به این ترتیب هستند: تعاریف سطح بالای این قطعات به شرح زیر است: پردازنده مرکزی یا Central Processing Unit (CPU): می‌تواند در هر ثانیه چندین کار را انجام دهد طوری که ما احساس کنیم کارها بطور موازی انجام می‌شوند. اینکه چه تعداد کار را در یک ثانیه انجام دهد، به سرعت پردازنده ما بستگی دارد. بطور مثال، اگر سرعت پردازنده ما 3.0 گیگاهرتز (3.0 Gigahertz) باشد، به معنی این است که به تعداد سه میلیارد کار در هر ثانیه، می‌تواند انجام دهد. حافظه اصلی یا Main Memory: برای ذخیره و دردسترس قرار دادن اطلاعات ضروری و مورد نیاز سریع پردازنده مرکزی، بکار می‌رود. اما باید مراقب اطلاعات خود در حافظه اصلی باشیم، چرا که با خاموش شدن کامپیوتر و یا راه‌اندازی مجدد (restart) اطلاعات آن از بین می‌رود. حافظه ثانویه یا (Secondary Memory): این نوع حافظه برای ذخیره دائمی اطلاعات بکارمی‌رود، اما سرعت آن از سرعت حافظه اصلی کمتر است. دستگاه‌های ورودی و خروجی یا (Input and Output Devices): همان وسایلی هستند که به کمک آن‌ها با کامپیوتر ارتباط برقرار می‌کنیم، شامل صفحه کلید، مانیتور، ماوس و … و ما به عنوان یک برنامه‌نویس مسئول این هستیم که به CPU بگوئیم چه زمانی چه کاری انجام دهد و از کدام دستگاه‌های ورودی و خروجی استفاده کند. به این ترتیب، ما همه این منابع را باهم هماهنگ می‌سازیم. "],["درک-برنامهنویسی.html", "1.2 درک برنامه‌نویسی", " 1.2 درک برنامه‌نویسی برای اینکه بتوانیم مهارت خوبی در برنامه‌نویسی بدست آوریم، دو نکته را در نظر داشته باشیم: اول اینکه باید با زبان برنامه‌نویسی موردنظر خود آشنا شویم یعنی لغات رزرو شده (Reserved Words) و گرامر زبان برنامه‌نویسی خوب است بدانیم برای هر زبان برنامه‌نویسی، لغاتی هستند که مفهوم خاصی داشته و کاربر برنامه‌نویس نمی‌تواند از آن‌ها برای منظور و کاربرد دیگری استفاده نماید. درعین حال، هر برنامه‌نویسی می‌تواند لغات خاص منظوره خود را به مفسر زبان برنامه‌نویسی خود معرفی کند. یکی از روش‌های انجام این کار، تعریف متغیر (Variable) است. کلمات رزرو شده توسط پایتون، شامل موارد ذیل می‌شوند: tibble( &quot;a&quot; = c(&quot;and&quot;, &quot;as&quot;, &quot;assert&quot;, &quot;break&quot;, &quot;class&quot;, &quot;continue&quot;), &quot;b&quot; = c(&quot;def&quot;, &quot;from&quot;, &quot;nonlocal&quot;, &quot;while&quot;, &quot;del&quot;, &quot;elif&quot;), &quot;c&quot; = c(&quot;else&quot;, &quot;except&quot;, &quot;finally&quot;, &quot;for&quot;, &quot;global&quot;, &quot;if&quot;), &quot;d&quot; = c(&quot;import&quot;, &quot;in&quot;, &quot;is&quot;, &quot;lambda&quot;, &quot;not&quot;, &quot;or&quot;), &quot;e&quot; = c(&quot;pass&quot;, &quot;raise&quot;, &quot;return&quot;, &quot;try&quot;, &quot;with&quot;, &quot;yield&quot;) ) %&gt;% kable( booktabs = TRUE, align = c(&quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;), caption = &quot;برخی از کلمات رزرو شده در پایتون&quot; ) %&gt;% my_table_style() rw = list (&quot;and&quot;, &quot;as&quot;, &quot;assert&quot;, &quot;break&quot;, &quot;class&quot;, &quot;continue&quot;, &quot;def&quot;, &quot;from&quot;, &quot;nonlocal&quot;, &quot;while&quot;, &quot;del&quot;, &quot;elif&quot;, &quot;else&quot;, &quot;except&quot;, &quot;finally&quot;, &quot;for&quot;, &quot;global&quot;, &quot;if&quot;, &quot;import&quot;, &quot;in&quot;, &quot;is&quot;, &quot;lambda&quot;, &quot;not&quot;, &quot;or&quot;, &quot;pass&quot;, &quot;raise&quot;, &quot;return&quot;, &quot;try&quot;, &quot;with&quot;, &quot;yield&quot;) knitr::kable(head(rw), booktabs = TRUE) and del global not with as elif if or yield assert else import pass break except in raise class finally is return continue for lambda try def from nonlocal while دوم اینکه، بتوانیم یک داستان بگوئیم! در واقع هنر حل مسئله، اصلی‌ترین مهارت یک برنامه‌نویس محسوب می‌شود. با کسب این مهارت، می‌توانیم زبان‌های برنامه‌نویسی دوم به بعد را راحت‌تر بیاموزیم. پس برای شروع، ما شروع به خواندن و توضیح برنامه‌ها می‌کنیم، آنگاه برنامه‌های ساده‌ می نویسیم، و سپس برنامه‌های پیچیده‌تر را در طول زمان می‌نویسیم. اگر خوب پیش برویم، خواهیم توانست روش و یا الگوریتم حل مسئله را از دیدگاه خودمان بنویسیم و آنگاه به مرور، مهارت حل خلاقانه مسئله را بدست خواهیم آورد. "],["اصطلاحات-مترجم-و-کامپایلر.html", "1.3 اصطلاحات: مترجم و کامپایلر", " 1.3 اصطلاحات: مترجم و کامپایلر پایتون یک زبان سطح بالا محسوب می‌شود. به این معنی که به زبان انسان نزدیک‌تر است تا به زبان سخت‌افزار کامپیوتر. اما مفهوم دستورات زبان‌های سطح بالا توسط CPU قابل فهم نیست. چراکه CPU فقط دستوراتی که به زبان ماشین باشند را درک می‌کند. زبان ماشین از دو نشانه 0 و 1 تشکیل شده است و CPU قادر است تنها همین زبان را بفهمد و دستورات آن را اجرا کند: 00101000111010010010101000000111111100110000011101010010101101101 پس برنامه‌های زبان‌های سطح بالایی مثل پایتون را چگونه باید برای CPU شرح داد؟ مترجم‌های متعددی برای ترجمه و تبدیل کدهای زبان سطح بالا به زبان سطح ماشین، وجود دارد. اما از آن‌جایی که زبان ماشین کاملا وابسته به سخت‌افزار کامپیوتر است، بنابراین ما یک زبان ماشین که بتواند با انواع سخت‌افزار هماهنگ شود را نداریم. برنامه‌های نوشته شده به زبان‌های سطح بالا را می‌توان با استفاده از یک مفسر متفاوت در ماشین ( همان سخت‌افزار) جدید یا کامپایل مجدد کد برای ایجاد نسخه زبان ماشین برنامه موردنظر برای ماشین جدید بین رایانه های مختلف جابجا کرد. این مترجمان زبان برنامه‌نویسی به دو دسته کلی تقسیم می شوند: (1) مفسر و (2) کامپایلر. یک مفسر کد برنامه نوشته شده توسط برنامه‌نویس را خوانده، آن را تجزیه می‌کند و دستورالعمل‌ها را تفسیر می‌نماید. با این توصیف، پایتون یک مفسر محسوب می‌شود که کدهای برنامه ما رافوراً پردازش می‌کند. برخی دستورات پایتون شامل مقادیری است که مجدداً دراثنای برنامه، برنامه‌نویس به آن نیاز خواهد داشت. بنابراین ما به عنوان برنامه‌نویس می‌بایست یک نام نمادین برای این مقادیر تعریف کنیم که در وقت لازم با این نام تعریف شده، پایتون را متوجه استفاده از آن مقدار موردنظر گردانیم. واژه‌ای که برای این نام مخصوص استفاده می‌شود، Variable یا متغیر است: &gt;&gt;&gt; x = 6 &gt;&gt;&gt; print(x) 6 &gt;&gt;&gt; y = x * 7 &gt;&gt;&gt; print(y) 42 در این مثال ساده، ما سعی کردیم به پایتون بگوییم در ابتدا برای مقدار 6، برچسبی به نام x درنظربگیرد و سپس در دستور بعدی همین مقدار را با نام x بازیابی کردیم. آنگاه آن را در 7 ضرب کرده و حاصل آن را در متغیر جدیدی با نام y ذخیره کردیم. دو خط مربوط به چاپ (print) مقادیر x و y صرفاً برای مشاهده مقادیر ذخیره شده در متغیرهای بکار رفته در پرانتز می‌باشد. #بخش دوم: متغیرها، عبارات و دستورات ‌ "],["عبارات-بولی.html", "1.4 عبارات بولی", " 1.4 عبارات بولی (Boolean Expressions) عبارت بولی عبارتی است که یا درست یا نادرست است. عملگر == برای بررسی درست یا نادرست بودن عبارت مورد استفاده قرار می‌گیرد. "],["بخش-سوم-اجرای-شرطی.html", "فصل 2 بخش سوم: اجرای شرطی ", " فصل 2 بخش سوم: اجرای شرطی "],["عبارات-بولی-1.html", "2.1 عبارات بولی1", " 2.1 عبارات بولی1 عبارت بولی عبارتی است که یا درست یا نادرست است. عملگر “==” برای مقایسه دو عملوند بکار می‌رود و نتیجه آن درستی (True) یا نادرستی (False) نتیجه این ارزیابی را نشان می‌دهد: &gt; 5 == 5 True &gt; 5 == 6 False عملگر == یکی از عملگرهای مقایسه‌ای است، سایر عملگرها عبارتند از: x != y # x is not equal to y x &gt; y # x is greater than y x &lt; y # x is less than y x &gt;= y # x is greater than or equal to y x &lt;= y # x is less than or equal to y x is y # x is the same as y x is not y # x is not the same as y "],["عملگرهای-منطقی.html", "2.2 عملگرهای منطقی", " 2.2 عملگرهای منطقی (Logical operators) سه عملگر منطقی وجود دارد: and, or و not . برای مثال: x &gt; 0 and x &lt; 10 عملوندهای عملگرهای منطقی باید عبارات بولی باشند، اما در پایتون هر عدد غیر صفر نیز به صورت True تفسیر می‌شود. &gt; 17 and True True "],["اجرای-شرطی.html", "2.3 اجرای شرطی", " 2.3 اجرای شرطی (Conditional execution) برای نوشتن یک برنامه کارآ، خیلی اوقات نیاز به بررسی شرایط مختلف داریم که براساس آن‌ها رفتارهای متفاوتی را طراحی کنیم. با استفاده از جملات شرطی (Conditional statements) می‌توانیم این قابلیت را بدست آوریم. if x &gt; 0 : print(&#39;x is positive&#39;) عبارت منطقی پس از if ، شرط یا (condition) نامیده می‌شود. #knitr::include_graphics(&quot;./img/Figure 3.1-- If Logic.PNG&quot;) اگر شرط منطقی درست باشد، دستور تورفتگی اجرا می‌شود. اگر شرط منطقی نادرست باشد، عبارت تورفتگی نادیده گرفته می‌شود. "],["اجرای-جایگزین.html", "2.4 اجرای جایگزین", " 2.4 اجرای جایگزین (Alternative execution) شکل دوم یک عبارت if اجرای جایگزین است که در آن دو حالت ممکن توسط شرط بررسی می‌شود که کدامیک می‌بایست اجرا شوند: if x%2 == 0 : print(&#39;x is even&#39;) else : print(&#39;x is odd&#39;) #knitr::include_graphics(&quot;./img/Figure 3.2 -- If-Then-Else Logic.PNG&quot;) ز آنجایی که شرط باید درست یا نادرست باشد، دقیقاً یکی از گزینه‌ها اجرا می‌شود. گزینه‌های جایگزین شاخه (Branch) نامیده می‌شوند، زیرا آنها شاخه‌هایی در جریان اجرا هستند. "],["شرطهای-زنجیرهای.html", "2.5 شرط‌های زنجیره‌ای", " 2.5 شرط‌های زنجیره‌ای (Chained conditionals) یکی از راه‌های بررسی بیش از سه شرط این است که: if x &lt; y: print(&#39;x is less than y&#39;) elif x &gt; y: print(&#39;x is greater than y&#39;) else: print(&#39;x and y are equal&#39;) #knitr::include_graphics(&quot;./img/Figure 3.3 -- If-Then-ElseIf Logic.PNG&quot;) "],["شرطهای-تو-در-تو.html", "2.6 شرط‌های تو در تو", " 2.6 شرط‌های تو در تو (Nested conditionals) یک عبارت شرطی نیز می‌تواند درون عبارن شرطی دیگری قرار گیرد: if x == y: print(&#39;x and y are equal&#39;) else: if x &lt; y: print(&#39;x is less than y&#39;) else: print(&#39;x is greater than y&#39;) #knitr::include_graphics(&quot;./img/Figure 3.4 -- Nested If Statements.PNG&quot;) "],["جلوگیری-از-استثناها-با-استفاده-از.html", "2.7 جلوگیری از استثناها با استفاده از", " 2.7 جلوگیری از استثناها با استفاده از try و except برخی اوقات در جریان برنامه‌نویسی شرطی، نیاز داریم که به مفسر پایتون بگوئیم براساس ورودی‌های مختلف چگونه رفتار کند تا کد برنامه ما با خطا رویرو نشود. مثلاً در برنامه از کاربر خواستیم مقداری عددی وارد کند و بر اساس این مقدار، قرار است محاسبه‌ای انجام گیرد. حال فرض کنید کاربر مقداری غیر عددی وارد کرد و آنگاه این مقدار غیرعددی در یک فرمول محاسباتی وارد می‌شود! چه اتفاقی می‌افتد؟ مفسر پایتون اجرای برنامه را قطع می‌کند، چرا که نتوانسته است مقدار غیرعددی را در محاسبات وارد کند. در این مواقع استفاده از ساختار try-except می‌تواند کمک‌کننده باشد: inp = input(&#39;Enter Fahrenheit Temperature:&#39;) try: fahr = float(inp) cel = (fahr - 32.0) * 5.0 / 9.0 print(cel) except: print(&#39;Please enter a number&#39;) در اینجا پایتون کار را با اجرای دستور try آغاز می‌کند و اگر همه چیز خوب باشد، بلاک except را درنظر نمی‌گیرد. اما اگر استثنایی در بلاک try رخ داد، مفسر پایتون از بلاک try عبور می‌کند و به اجرای بلاک except می‌پردازد. "],["بخش-چهارم-توابع.html", "فصل 3 بخش چهارم: توابع ", " فصل 3 بخش چهارم: توابع "],["فراخوانی-تابع.html", "3.1 فراخوانی تابع", " 3.1 فراخوانی تابع در حوزه برنامه‌نویسی، یک تابع دنباله‌ای از جملات است که یک محاسبات را انجام می‌دهد. درواقع ما با تعیین یک نام و یک سری دستورات، می‌توانیم یک تابع را تعریف کنیم و آنگاه با صداکردن نام آن تابع، خواهیم توانست آن را فراخوانی کنیم. بسیاری از دستوراتی را که تابحال از آن‌ها استفاده می‌کردیم، درواقع تابع بودند: type(32) &lt;class &#39;int&#39;&gt; که در این جا نام تابع type است. "],["توابع-داخلی.html", "3.2 توابع داخلی2", " 3.2 توابع داخلی2 این‌ها توابعی هستند که توسط سازندگان پایتون تعبیه شده‌اند و برای حل مسائل عمومی مورد استفاده قرار می‌گیرند. نمونه‌ای از این توابع عبارتند از: max(&#39;Hello world&#39;) &#39;w&#39; min(&#39;Hello world&#39;) &#39; &#39; len(&#39;Hello world&#39;) 11 "],["توابع-تبدیل-نوع.html", "3.3 توابع تبدیل نوع3", " 3.3 توابع تبدیل نوع3 این‌ها نوع دیگری از توابع داخلی هستند که مقدار یک نوع را به نوعی دیگر تبدیل می‌کنند: int(3.99999) 3 int(-2.3) -3 float(&#39;3.14159&#39;) 3.14159 "],["توابع-ریاضی.html", "3.4 توابع ریاضی4", " 3.4 توابع ریاضی4 پایتون دارای یک ماژول ریاضی است که اکثر توابع ریاضی مشهور را ارائه می‌دهد. اما قبل از اینکه بتوانیم از ماژول استفاده کنیم، باید آن را وارد5 کنیم: import math این عبارت یک شی ماژول به نام math ایجاد می کند. برای دسترسی به یکی از توابع، باید نام ماژول و نام تابع را که با یک نقطه از هم جدا شده اند (که به عنوان نقطه نیز شناخته می شود) مشخص کنیم. به این فرمت، علامت نقطه می گویند. ratio = signal_power / noise_power decibels = 10 * math.log10(ratio) radians = 0.7 height = math.sin(radians) import↩︎ "],["اعداد-تصادفی.html", "3.5 اعداد تصادفی6", " 3.5 اعداد تصادفی6 به نظر می‌رسد که ساختن یک برنامه واقعاً غیر قطعی چندان آسان نیست، اما راه‌هایی وجود دارد که حداقل غیرقطعی به نظر برسد. یکی از آنها استفاده از الگوریتم‌هایی است که اعداد شبه تصادفی تولید می‌کنند. درست است که اعداد شبه تصادفی واقعاْ تصادفی نیستند اما بازهم تمایز آن‌ها از اعداد تصادفیُ غیرممکن است. ماژول random توابعی را بدست می‌دهد که اعداد تصادفی تولید می‌کنند. یک مثال را باهم ببینیم: import random for i in range(10): x = random.random() print(x) 0.0920530236235576 0.6250171315179012 0.7706549349232131 0.7402147110407385 0.15988207593735793 0.4024047009691475 0.8179640452074257 0.44502244153994786 0.8980030614870437 0.9357510761663985 این برنامه یک لیستی از اعداد تصادفی بین 0 و 1 تولید می‌کند که شامل 1 نمی‌شوند: مثال‌هایی دیگر از توابع random‌ عبارتند از: random.randint(5, 10) 7 t = [1, 2, 3] random.choice(t) 3 "],["افزودن-یک-تابع-جدید.html", "3.6 افزودن یک تابع جدید", " 3.6 افزودن یک تابع جدید ما معمولاْ برای پیشبرد اهداف برنامه موردنظرمان، نیاز به تعریف توابع جدید خواهیم داشت. این توابع در آینده بارها و بارها می‌توانند مورد استفاده قرار گیرند. در مثال زیر، یک تابع به نام print_lyrics تعریف می‌کنیم: def print_lyrics(): print(&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;) print(&#39;I sleep all night and I work all day.&#39;) همانطور که در این مثال می‌بینید، کلمه کلیدی def برای تعریف تابع بکار برده می‌شود. با تعریف یک تابع، یک متغیر با همان نام ایجاد می‌شود. نحو فراخوانی تابع جدید مانند توابع داخلی است: print_lyrics() I&#39;m a lumberjack, and I&#39;m okay. I sleep all night and I work all day. ما حتی می‌توانیم یک تابع تعریف شده را درون تابع دیگر، فراخوانی کنیم. "],["پارامترها-و-آرگومانها.html", "3.7 پارامترها و آرگومان‌ها", " 3.7 پارامترها و آرگومان‌ها برخی از توابع داخلی که دیده‌ایم به آرگومان نیاز دارند. برای مثال، وقتی تابع math.sin را فراخوانی می‌کنیم، باید یک عدد را به آن بدهیم. به این ورودی، آرگومان7 گفته می‌شود. argument↩︎ "],["توابع-دارای-خروجی-و-توابع-بدون-خروجی.html", "3.8 توابع دارای خروجی و توابع بدون خروجی8", " 3.8 توابع دارای خروجی و توابع بدون خروجی8 در اجرای برخی توابع، با اتمام آخرین دستور تابع، مقداری را به عنوان نتیجه9 در خروجی می‌بینیم. import math math.sqrt(5) 2.23606797749979 اما این اتفاق برای همه توابع رخ نمی‌دهد. درواقع این توابع کاری را انجام داده‌اند که بصورت خروجی قابل نمایش نیست. این توابع را void function می‌نامند: def No_reult_func (): x = math.cos(radians) Fruitful functions↩︎ "],["Iteration.html", "فصل 4 بخش پنجم: تکرار (Iteration) ", " فصل 4 بخش پنجم: تکرار (Iteration) "],["عبارت-while.html", "4.1 عبارت ‘While’", " 4.1 عبارت ‘While’ برای شروع آشنایی با عبارت و در حقیقت ساختار ‘While’ به مثال زیر توجه کنید: n = 5 while n &gt; 0: print(n) n = n - 1 print(&#39;Blastoff!&#39;) 5 4 3 2 1 Blastoff! به این معنی که “تا وقتی که n بزرگتر از 0 است، مقدار n را نمایش بده و سپس مقدار n را به اندازه 1 واحد کاهش بده. وقتی مقدار n به 0 رسید، کنترل برنامه از دستور while خارج می‌شود و کلمه Blastoff را نمایش می‌دهد! ساختار استفاده از عبارت ‘While’ به شرح زیر است: شرایط را ارزیابی کنید، درست یا غلط را نشان دهید. اگر شرط نادرست است، از دستور while خارج شده و در دستور بعدی اجرا را ادامه دهید. اگر شرط درست است، بدنه را اجرا کنید و سپس به مرحله 1 برگردید. این نوع جریان حلقه نامیده می‌شود زیرا در مرحله سوم به سمت بالا باز می‌گردد. هر بار که بدنه حلقه را اجرا می‌کنیم، آن را یک تکرار می‌نامیم. برای حلقه بالا، می‌گوییم: «پنج تکرار داشت»، یعنی بدنه حلقه پنج بار اجرا شده است. بدنه حلقه باید مقدار یک یا چند متغیر را تغییر دهد تا در نهایت شرط نادرست شود و حلقه خاتمه یابد. ما متغیری را که هر بار که حلقه اجرا می‌شود و مقدار متغیر تغییر می‌کند، فراخوانی می‌کنیم و نیز زمانی که حلقه، مقدار متغیر تکرار را به پایان می‌رساند، اگر متغیر تکراری وجود نداشته باشد، حلقه برای همیشه تکرار می‌شود و در نتیجه یک حلقه بی نهایت ایجاد می‌شود. "],["حلقههای-بینهایت.html", "4.2 حلقه‌های بی‌نهایت10", " 4.2 حلقه‌های بی‌نهایت10 در مورد شمارش معکوس، می‌توانیم ثابت کنیم که حلقه خاتمه می‌یابد زیرا می‌دانیم که مقدار n محدود است و می‌بینیم که مقدار n هر بار از طریق حلقه کوچکتر می‌شود، بنابراین در نهایت باید به 0 برسیم. در سایر مواقع، یک حلقه بی‌نهایت است زیرا هیچ متغیر تکراری ندارد (به شبه شرط منطقی داخل پرانتز در عبارت break دقت کنید). کاربرد حلقه بی‌نهایت در این است که برخی اوقات تا زمانی که نیمی از بدنه را طی نکنیم، نمی‌دانیم آیا زمان پایان دادن به یک حلقه فرا رسیده است. در این صورت می‌توانیم یک حلقه بی‌نهایت را عمداً بنویسیم و سپس از دستور break برای پرش از حلقه استفاده کنیم. n = 10 while True: print(n, end=&#39; &#39;) n = n - 1 print(&#39;Done!&#39;) اگر مرتکب اشتباه شویم و این کد را اجرا کنیم، یاد خواهیم گرفت که چگونه فرآیند و یا مسیر پایتون را در سیستم خود متوقف کنیم و یا آن را خاتمه دهیم. این برنامه برای همیشه یا تا زمانی که باتری ما تمام شود اجرا می‌شود زیرا عبارت منطقی در بالای حلقه به دلیل این که عبارت مقدار ثابت True است همیشه درست است. مثال زیر، کاربرد break را به خوبی نشان می‌دهد: while True: line = input(&#39;&gt; &#39;) if line == &#39;done&#39;: break print(line) print(&#39;Done!&#39;) "],["اتمام-تکرارها-با.html", "4.3 اتمام تکرارها با", " 4.3 اتمام تکرارها با continue گاهی اوقات ما در یک تکرار یک حلقه هستیم و می‌خواهیم تکرار فعلی را تمام کنیم و بلافاصله به تکرار بعدی برویم. در آن صورت می‌توانیم از دستور continue برای پرش به تکرار بعدی استفاده کنیم، بدون اینکه بدنه حلقه برای تکرار فعلی تمام شود. while True: line = input(&#39;&gt; &#39;) if line[0] == &#39;#&#39;: continue if line == &#39;done&#39;: break print(line) print(&#39;Done!&#39;) ##حلقه‌های معین با استفاده از for گاهی اوقات می‌خواهیم مجموعه‌ای از چیزها را مانند فهرستی از کلمات، خطوط یک فایل یا فهرستی از اعداد را بصورت حلقه‌ای ایجاد کنیم. وقتی لیستی از چیزهایی که باید از طریق آنها حلقه بزنیم داریم، می توانیم با استفاده از دستور for یک حلقه معین بسازیم. دستور while را یک حلقه نامعین می نامیم زیرا به سادگی حلقه می‌زند تا زمانی که برخی از شرط‌ها False شود، در حالی که حلقه for در مجموعه‌ای شناخته شده از آیتم‌ها حلقه می‌زند بنابراین به تعداد آیتم‌های مجموعه، تکرار می‌شود. friends = [&#39;Joseph&#39;, &#39;Glenn&#39;, &#39;Sally&#39;] for friend in friends: print(&#39;Happy New Year:&#39;, friend) print(&#39;Done!&#39;) "],["بخش-ششمرشتهها.html", "فصل 5 بخش ششم:رشته‌ها ", " فصل 5 بخش ششم:رشته‌ها "],["محاسبه-طول-متن.html", "5.1 محاسبه طول متن", " 5.1 محاسبه طول متن ‘len’ یک تابع داخلی در پایتون است که تعداد کاراکترهای یک رشته را برمی‌گرداند. fruit = &#39;banana&#39; length = len(fruit) حال اگر این عدد را به عنوان اندیس متغیر رشته استفاده کنیم، آخرین کاراکتر رشته را بدست می‌آوریم: last = fruit[length - 1] print(last) دلیل این تفریق این است که شماره اندیس اولین کاراکتر رشته، با صفر شروع می‌شود. بنابراین برای دستیابی به موقعیت‌های دیگر یک رشته، می‌توان اندیس‌ها را تغییر داد: fruit = &#39;banana&#39; fruit[:3] "],["رشتهها-تغییرناپذیرند.html", "5.2 رشته‌ها تغییرناپذیرند", " 5.2 رشته‌ها تغییرناپذیرند درعین حال اینکه می‌توان به همه کاراکترهای یک رشته دست پیدا کرد، اما نمی‌توان کاراکتر دیگری را جایگزین یکی از کاراکترهای رشته کرد: greeting = &#39;Hello, world!&#39; greeting[0] = &#39;J&#39; اگر این دستور را اجرا کنید، با خطا مواجه می‌شوید، چراکه رشته‌ها قابل تغییر نیستند. "],["عملگر.html", "5.3 عملگر", " 5.3 عملگر ‘in’ گاربرد این عملگر زمانی است که می‌خواهیم بدانیم آیا یک رشته حاوی یک رشته و یا کاراکتر خاصی هست یا خیر: &#39;a&#39; in &#39;banana&#39; و یا این حالت: &#39;seed&#39; in &#39;banana&#39; همچنین با استفاده از عملگرهای ‘&lt;’ و ‘&gt;’ می‌توانیم رشته‌ها را از نظر ترتیب حروف الفبا با یکدیگر مقایسه کنیم: if word &lt; &#39;banana&#39;: print(&#39;Your word,&#39; + word + &#39;, comes before banana.&#39;) elif word &gt; &#39;banana&#39;: print(&#39;Your word,&#39; + word + &#39;, comes after banana.&#39;) else: print(&#39;All right, bananas.&#39;) "],["متدهای-رشتهای.html", "5.4 متدهای رشته‌ای11", " 5.4 متدهای رشته‌ای11 پایتون تابعی به نام ‘dir’ دارد که متدهای مربوط به یک شیئ را لیست می‌کند و همچنین با استفاده از ‘type’ می‌توانیم نوع شیئ را تشخیص دهیم: stuff = &#39;Hello world&#39; type(stuff) و dir(stuff) روش دیگر برای یافتن موقعیت یک زیررشته و یا یک کاراکتر خاص در یک رشته اصلی، استفاده از متد [‘find’]{dir-ltr} می‌باشد: word = &#39;banana&#39; index = word.find(&#39;a&#39;) print(index) خوب است با متدهای strip و startwith و lower برای آشنایی بیشتر با متدهای رشته‌ای، در برنامه پایتون خودمان تمرین کنیم. "],["عملگر-فرمت.html", "5.5 عملگر فرمت12", " 5.5 عملگر فرمت12 عملگر format %، به ما اجازه می‌دهد تا رشته‌ها را بسازیم و بخش‌هایی از رشته‌ها را با داده‌های ذخیره شده در متغیرها جایگزین کنیم: camels = 42 &#39;%d&#39; % camels در مثال بالا توانستیم حروف 4 و 2 را به عدد 42 تبدیل کنیم. d مخفف “اعشاری” است. و یا این مثال: camels = 42 &#39;I have spotted %d camels.&#39; % camels به همین ترتیب، عملگرهای ‘%g’ و ‘%s’ وظیفه قالب‌بندی یک عدد ممیز شناور و قالب‌بندی یک رشته را به عهده دارند: &#39;In %d years I have spotted %g %s.&#39; % (3, 0.1, &#39;camels&#39;) "],["بخش-هفتم-فایلها.html", "فصل 6 بخش هفتم: فایل‌ها ", " فصل 6 بخش هفتم: فایل‌ها "],["بازکردن-فایل.html", "6.1 بازکردن فایل", " 6.1 بازکردن فایل ممکن است داده‌های ما از قبل در فایلی موجود باشد، دراینصورت باید بتوانیم آن را باز کنیم: fhand = open(&#39;./ref/mbox.txt&#39;) print(fhand) اگر باز کردن موفقیت‌آمیز باشد، سیستم‌عامل یک ‘handle’ برای فایل به ما برمی‌گرداند. ‘handle’، داده‌های واقعی موجود در فایل نیست، اما در عوض یک ‘handle’ است که می‌توانیم برای خواندن داده‌ها از آن استفاده کنیم. اگر فایل درخواستی وجود داشته باشد و مجوزهای لازم برای خواندن فایل را داشته باشیم، به ما یک ‘handle’ داده می شود. #knitr::include_graphics(&quot;./img/Figure 7.2-- A File Handle.PNG&quot;) اما چنانچه فایل وجود نداشته باشد، اجرای این دستور ناموفق خواهد بود و ‘handle’ نخواهیم داشت: Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; FileNotFoundError: [Errno 2] No such file or directory: 'stuff.txt' "],["خواندن-فایل.html", "6.2 خواندن فایل", " 6.2 خواندن فایل با بازکردن فایل، تنها یک handle در اختیار خواهیم داشت تا بتوانیم با استفاده از آن با فایل موردنظر کار کنیم. بنابریان برای خواندن فایل، می‌بایست با یک دستور حلقه ‘for’ ساده، اقدام به خواندن فایل کنیم: fhand = open(&#39;./ref/mbox.txt&#39;) count = 0 for line in fhand: count = count + 1 print(&#39;Line Count:&#39;, count) با این دستورات، ما سعی کرده‌ایم که فایل را خط به خط بخوانیم. اما این طریقه خواندن برای فایل‌های بزرگ مورد استفاده قرار می‌گیرد. اگر فایلی داشته باشیم و بدانیم حجم آن کم است، می‌توانیم از دستورات زیر استفاده کنیم: fhand = open(&#39;./ref/mbox.txt&#39;) inp = fhand.read() print(len(inp)) print(inp[:20]) در این حالت بهتر است رشته خوانده شده از فایل را در یک متغیر ذخیره کنیم، چراکه با خواندن فایل بعدی به همین روش، محتویات فایل قبلی را از دست خواهیم داد، به همین دلیل ما از متغیر inp در دستورات فوق استفاده کردیم. "],["جستجو-در-فایل.html", "6.3 جستجو در فایل", " 6.3 جستجو در فایل اگر در فایل محتویات داده به دنبال کلمه و یا داده خاصی هستیم، می‌توانیم آن را در فایلی که از قبل آن را باز کرده و خوانده‌ایم، جستجو کنیم: fhand = open(&#39;./ref/mbox.txt&#39;) count = 0 for line in fhand: line = line.rstrip() if line.startswith(&#39;From:&#39;): print(line) در این مثال، ما به دنبال کلمه 'From' هستیم. ما با استفاده از تابع rstrip() فضای خالی را در سمت راست رشته موجود در فایل، حذف کرده‌ایم. "],["اجازه-دادن-به-کاربر-برای-انتخاب-نام-فایل.html", "6.4 اجازه دادن به کاربر برای انتخاب نام فایل", " 6.4 اجازه دادن به کاربر برای انتخاب نام فایل این مسئله برای ما پیش آمده که برای باز کردن یک فایل، همیشه نام و آدرس دقیق آن را نمی‌دانیم و نیاز است تا بتوانیم در مرورگر سیستم فایل خود، آن را جستجو کنیم. به این منظور، با استفاده از قطعه کد زیر، این امکان را به کاربر می‌دهیم که فایل موردنظر خود را ابتدا جستجو و سپس باز کند. در اینصورت ما دیگر نام فایل را بصورت مستقیم در کد خود نخواهیم داشت: fname = input(&#39;Enter the file name: &#39;) fhand = open(fname) count = 0 for line in fhand: if line.startswith(&#39;Subject:&#39;): count = count + 1 print(&#39;There were&#39;, count, &#39;subject lines in&#39;, fname) "],["استفاده-از.html", "6.5 استفاده از", " 6.5 استفاده از try، except و open از کد قبل به خاطر داریم که ما به کاربر اجازه دادیم که نام فایل حود را برای بازکردن، انتخاب نماید. حال اگر کاربر ما چیزی را تایپ کند که نام فایل نیست چه؟ بنابراین باید تمهیداتی برای این کار بیاندیشیم، چرا که گذشته از اینکه بازکردن یک فایل غیرمرتبط برنامه را با خطا مواجه می‌کند، ممکن است فایلی که کاربر آن را انتخاب کرده، عمداً و یا سهواً برای برنامه ما ضرر داشته باشد. بنابراین ما با ایتفاده از دستورات try ، except و open این اتفاق را مدیریت می‌کنیم: fname = input(&#39;Enter the file name: &#39;) try: fhand = open(fname) except: print(&#39;File cannot be opened:&#39;, fname) exit() count = 0 for line in fhand: if line.startswith(&#39;Subject:&#39;): count = count + 1 print(&#39;There were&#39;, count, &#39;subject lines in&#39;, fname) همانطور که مشاهده می‌شود، تابع exit() درصورت اینکه کاربر چیزی غیر از فایل را درخواست داده باشد، برنامه ما از اجرا خارج می‌شود. "],["نوشتن-در-فایل.html", "6.6 نوشتن در فایل", " 6.6 نوشتن در فایل بیشتر اوقات افراد نیاز دارند که در فایل داده خود، ویرایش انجام داده یا داده جدیدی به آن بیافزایند. بنابراین باید قادر باشند که با استفاده از دستورات لازم، این کار را انجام دهند. اما یک نکته متفاوت اینجا مطرح می‌شود، به این قطعه کد توجه کنید: fout = open(&#39;output.txt&#39;, &#39;w&#39;) print(fout) در اینجا چنانچه فایل موردنظر وجود داشته باشد، فایل باز شده و آماده نوشتن می‌باشد: در واقع پارمتر ‘w’ این اجازه را صادر می‌کند. اما اگر فایل موجود نباشد، یک فایل جدید با نام ذکر شده، ایجاد می‌شود و آماده نوشتن خواهد بود. مثلاً فرض کنیم می‌خواهیم متن زیر را در فایل بنویسیم: This here's the wattle کد لازم برای این کار، به شکل زیر خواهد بود: line1 = &quot;This here&#39;s the wattle,\\n&quot; fout.write(line1) و درنهایت اینکه وقتی کارمان با فایلی تمام شد، می‌بایست حتماً آن را ببندیم: fout.close() "],["بخش-هشتم-لیستها.html", "فصل 7 بخش هشتم: لیست‌ها ", " فصل 7 بخش هشتم: لیست‌ها "],["لیست-یک-دنباله-است.html", "7.1 لیست یک دنباله است", " 7.1 لیست یک دنباله است برای کنارهم قرار دادن چندین داده با نوع مختلف، می‌توان از لیست استفاده کرد. یکی از راه‌های ایجاد لیست، بکاربردن براکت در تعریف آن است: cheeses = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] numbers = [17, 123] empty = [] print(cheeses, numbers, empty) اما همانطور که گفته بودیم، عناصر لیست می‌توانند نوع‌های متفاوت از هم داشته باشند: multi_types_items = [&#39;spam&#39;, 2.0, 5, [10, 20]] در دو مثال قبلی؛ تعداد عناصر لیست را به این شکل محاسبه می‌کنیم: لیست cheeses دارای 3 عنصر است. لیست numbers دو عنصر دارد و لیست multi_types_items شامل 4 عنصر می‌شود. چراکه لیست داخلی که شامل عناصر 10 و 20 هست، در لیست اصلی، به عنوان یک عنصر و یا داده درنظرگرفته می‌شود. برای تغییر مقادیر موجود در لیست، می‌بایست بتوانیم به هر داده دسترسی داشته باشیم، به این منظور از اندیس برای آدرس‌دهی استفاده می‌کنیم: numbers = [17, 123] numbers[1] = 5 print(numbers) و یا برای اینکه بدانیم داده مورد نظر ما در لیست قرار گرفته یا خیر، می‌توان از این روش استفاده کرد: cheeses = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] &#39;Edam&#39; in cheeses و یا: cheeses = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] &#39;Brie&#39; in cheeses "],["پیمایش-در-لیست.html", "7.2 پیمایش در لیست", " 7.2 پیمایش در لیست مواقعی هست که می‌خواهیم کل یک لیست را پیمایش کنیم و داده‌های آن را در یک عملیات محاسبه‌ای و یا هرنوع عملیات دیگر، وارد سازیم، در اینصورت: for cheese in cheeses: print(cheese) این کار بسیار ساده بود. چرا که ما تمام لیست را یکی یکی پیمایش کردیم و آن را در خروجی چاپ کردیم. اما اگر نیاز داشته باشیم که در حین پیمایش، داده‌ای از لیست را تغییر دهیم، چه روشی را باید درپیش بگیریم؟ for i in range(len(numbers)): numbers[i] = numbers[i] * 2 "],["کارکردن-با-عناصر-لیست.html", "7.3 کارکردن با عناصر لیست", " 7.3 کارکردن با عناصر لیست در قطعه کد زیر، به ترتیب با استفاده از عملگرهای ‘+’ و ’*’ آشنا می‌شویم و سپس نحوه برش‌های مختلف لیست را یادمی‌گیریم: a = [1, 2, 3] b = [4, 5, 6] c = a + b print(c) [1, 2, 3] * 3 t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] t[1:3] t[:4] t[3:] "],["متدهای-لیست.html", "7.4 متدهای لیست", " 7.4 متدهای لیست برای اضافه کردن یک عنصر به انتهای لیست، می‌توانیم از متد ‘append()’ استفاده کنیم: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] t.append(&#39;d&#39;) print(t) همچنین متد ‘extend()’ یک لیست را به عنوان آرگومان ورودی دریافت می‌کند و آن را به انتهای لیست معرفی شده، اضافه می‌کند: t1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] t2 = [&#39;d&#39;, &#39;e&#39;] t1.extend(t2) print(t1) برای مرتب کردن عناصر یک لیست، متد ‘sort()’ در اختیار ماست: t = [&#39;d&#39;, &#39;c&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;] t.sort() print(t) اگر چنانچه خواسته باشیم عنصری را از داخل یک لیست حذف کنیم، با دانستن اندیس موقعیت آن عنصر، می‌توانیم از متد ‘pop(i)’ استفاده کنیم: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] x = t.pop(1) print(t) print(x) اگر در استفاده از دستور ‘pop()’ اندیس استفاده نشود، این متد، آخرین عنصر آرایه را حذف خواهد کرد. به کد زیر و نتیجه اجرای آن دقت کنید: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] del t[1] print(t) به نظر شما تفاوت استفاده از متدهای pop(i) و del list_name[i] در چیست؟ بله، درست است که هر دو باعث حذف یک عنصر از لیست می‌شوند اما در استفاده از متد pop(i) عنصر حذف شده در اختیار ما خواهد بود. به این معنی که خروجی این متد، نمایانگر مقدار عنصر حذف شده است. اما در استفاده از دستور del list_name[i] عنصری که حذف شده دیگر در دسترس ما نخواهد بود. حال به این سوال فکر کنید که اگر اندیس عنصر موردنظر برای حذف کردن را ندانیم، از چه روشی می‌توانیم آن عنصر خاص را حذف کنیم؟ درواقع پایتون برای این منظور متد remove(item_value) را پیشنهاد می‌دهد که با ارسال مقدار عنصر موردنظر به عنوان آرگومان ورودی به این متد، می‌توانیم آن را از لیست حذف کنیم: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] t.remove(&#39;b&#39;) print(t) و یا برای حذف بیش از یک مقدار، با دانستن اندیس آن‌ها می‌توان از روش زیر استفاده کرد: t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] del t[1:5] print(t) "],["برخی-توابع-مهم-مربوط-به-لیست.html", "7.5 برخی توابع مهم مربوط به لیست", " 7.5 برخی توابع مهم مربوط به لیست در کدهای زیر نام و کاربرد برخی توابع مهم برای استفاده در لیست‌ها معرفی شده‌اند: nums = [3, 41, 12, 9, 74, 15] print(len(nums)) print(max(nums)) print(min(nums)) print(sum(nums)) print(sum(nums)/len(nums)) "],["لیستها-و-رشتهها.html", "7.6 لیست‌ها و رشته‌ها", " 7.6 لیست‌ها و رشته‌ها یک رشته، دنباله‌ای از کاراکترهاست و یک لیست دنباله‌ای از عناصر. اما یک لیست از کاراکترها، همانند یک رشته نیست. برای تبدیل یک رشته به یک لیست، می‌توان از متد یا تابع list(string_name) استفاده کرد: s = &#39;spam&#39; t = list(s) print(t) اما اگر بخواهیم رشته‌ای از کلمات را به لیست تبدیل کنیم، چه باید کرد: s = &#39;pining for the fjords&#39; t = s.split() print(t) و یا مثالی دیگر که در آن با کاربرد توابع split(delimiter) و join(list_name) آشنا می‌شویم: s = &#39;spam-spam-spam&#39; delimiter = &#39;-&#39; s.split(delimiter) t = [&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;] delimiter = &#39; &#39; delimiter.join(t) "],["فصل-اول-r.html", "فصل 8 فصل اول R", " فصل 8 فصل اول R یه ویرایش ساده "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
