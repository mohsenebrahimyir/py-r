# بخش هفتم: فایل‌ها{#files}


## بازکردن فایل

ممکن است داده‌های ما از قبل در فایلی موجود باشد، دراینصورت باید بتوانیم آن را 
باز کنیم:

```python
fhand = open('./ref/mbox.txt')
print(fhand)
```

اگر باز کردن موفقیت‌آمیز باشد، سیستم‌عامل یک 
['handle ']{dir=ltr}
 برای فایل به ما برمی‌گرداند. 
['handle']{dir=ltr}، 
داده‌های واقعی موجود در فایل نیست، اما در عوض یک 
['handle']{dir=ltr}
 است که می‌توانیم برای خواندن داده‌ها از آن استفاده کنیم. 
اگر فایل درخواستی وجود داشته باشد و مجوزهای لازم برای 
خواندن فایل را داشته باشیم، به ما یک 
['handle']{dir=ltr}
 داده می شود.
 
 
 ```{r}
#knitr::include_graphics("./img/Figure 7.2-- A File Handle.PNG")
```

اما چنانچه فایل وجود نداشته باشد، اجرای این دستور ناموفق خواهد بود و 
['handle']{dir=ltr}
نخواهیم داشت: 

[`Traceback (most recent call last):`]{dir=ltr}
[`File "<stdin>", line 1, in <module>`]{dir=ltr}
[`FileNotFoundError: [Errno 2] No such file or directory: 'stuff.txt'`]{dir=ltr}

## خواندن فایل

با بازکردن فایل، تنها یک 
[`handle`]{dir=ltr} 
در اختیار خواهیم داشت تا بتوانیم با استفاده از آن با فایل موردنظر کار کنیم. 
بنابریان برای خواندن فایل، می‌بایست با یک دستور حلقه 
['for']{dir=ltr} 
ساده، اقدام به خواندن فایل کنیم:


```python
fhand = open('./ref/mbox.txt')
count = 0
for line in fhand:
  count = count + 1
print('Line Count:', count)
```

با این دستورات، ما سعی کرده‌ایم که فایل را خط به خط بخوانیم. 
اما این طریقه خواندن برای فایل‌های بزرگ مورد استفاده قرار می‌گیرد. 
اگر فایلی داشته باشیم و بدانیم حجم آن کم است، می‌توانیم از دستورات زیر 
استفاده کنیم:


```python
fhand = open('./ref/mbox.txt')
inp = fhand.read()
print(len(inp))
```


```python
print(inp[:20])
```


در این حالت بهتر است رشته خوانده شده از فایل را در یک متغیر ذخیره کنیم، چراکه 
با خواندن فایل بعدی به همین روش، محتویات فایل قبلی را از دست خواهیم داد، 
به همین دلیل ما از متغیر 
`inp`
در دستورات فوق استفاده کردیم.


## جستجو در فایل

اگر در فایل محتویات داده به دنبال کلمه و یا داده خاصی هستیم، می‌توانیم آن را 
در فایلی که از قبل آن را باز کرده و خوانده‌ایم، جستجو کنیم:


```python
fhand = open('./ref/mbox.txt')
count = 0
for line in fhand:
  line = line.rstrip()
  if line.startswith('From:'):
    print(line)
```

در این مثال، ما به دنبال کلمه 
[`'From'`]{dir=ltr} 
هستیم.


ما با استفاده از تابع 
[`rstrip()`]{dir=ltr} 
فضای خالی را در سمت راست رشته موجود در فایل، حذف کرده‌ایم.


## اجازه دادن به کاربر برای انتخاب نام فایل


این مسئله برای ما پیش آمده که برای باز کردن یک فایل، همیشه نام و آدرس دقیق آن
را نمی‌دانیم و نیاز است تا بتوانیم در مرورگر سیستم فایل خود، آن را جستجو کنیم. 
به این منظور، با استفاده از قطعه کد زیر، این امکان را به کاربر می‌دهیم که فایل 
موردنظر خود را ابتدا جستجو و سپس باز کند. در اینصورت ما دیگر نام فایل را بصورت 
مستقیم در کد خود نخواهیم داشت:

```python
fname = input('Enter the file name: ')
fhand = open(fname)
count = 0
for line in fhand:
  if line.startswith('Subject:'):
    count = count + 1
print('There were', count, 'subject lines in', fname)
```


## استفاده از 
[`try`]{dir=ltr}،
[`except`]{dir=ltr} و
[`open`]{dir=ltr} 


از کد قبل به خاطر داریم که ما به کاربر اجازه دادیم که نام فایل حود را برای 
بازکردن، انتخاب نماید. حال اگر کاربر ما چیزی را تایپ کند که نام فایل نیست چه؟
بنابراین باید تمهیداتی برای این کار بیاندیشیم، چرا که گذشته از اینکه بازکردن 
یک فایل غیرمرتبط برنامه را با خطا مواجه می‌کند، ممکن است فایلی که کاربر آن را 
انتخاب کرده، عمداً و یا سهواً برای برنامه ما ضرر داشته باشد. بنابراین ما با 
ایتفاده از  دستورات 
[`try`]{dir=ltr} ،
[`except`]{dir=ltr} و
[`open`]{dir=ltr} 
این اتفاق را مدیریت می‌کنیم:


```python
fname = input('Enter the file name: ')
try:
  fhand = open(fname)
except:
  print('File cannot be opened:', fname)
  exit()
count = 0
for line in fhand:
  if line.startswith('Subject:'):
    count = count + 1
print('There were', count, 'subject lines in', fname)
```

همانطور که مشاهده می‌شود، تابع 
[`exit()`]{dir=ltr} 
درصورت اینکه کاربر چیزی غیر از فایل را درخواست داده باشد، برنامه ما از اجرا 
خارج می‌شود.

## نوشتن در فایل 


بیشتر اوقات افراد نیاز دارند که در فایل داده خود، ویرایش انجام داده یا 
داده جدیدی به آن بیافزایند. بنابراین باید قادر باشند که با استفاده از دستورات 
لازم، این کار را انجام دهند. اما یک نکته متفاوت اینجا مطرح می‌شود، 
به این قطعه کد توجه کنید:

```python
fout = open('output.txt', 'w')
print(fout)
```

در اینجا چنانچه فایل موردنظر وجود داشته باشد، فایل باز شده و آماده نوشتن می‌باشد:
در واقع پارمتر 
['w']{dir=ltr} 
این اجازه را صادر می‌کند. اما اگر فایل موجود نباشد، یک فایل جدید با نام ذکر شده، 
ایجاد می‌شود و آماده نوشتن خواهد بود.

مثلاً فرض کنیم می‌خواهیم متن زیر را در فایل بنویسیم: 

[`This here's the wattle`]{dir=ltr} 

کد لازم برای این کار، به شکل زیر خواهد بود:

```python
line1 = "This here's the wattle,\n"
fout.write(line1)
```

و درنهایت اینکه وقتی کارمان با فایلی تمام شد، می‌بایست حتماً آن را ببندیم:

```python
fout.close()
```

