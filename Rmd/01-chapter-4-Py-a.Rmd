‌

# بخش چهارم: توابع

## فراخوانی تابع

در حوزه برنامه‌نویسی، یک تابع دنباله‌ای از جملات است که یک محاسبات را انجام می‌دهد.
درواقع ما با تعیین یک نام و یک سری دستورات، می‌توانیم یک تابع را تعریف کنیم 
و آنگاه با صداکردن نام آن تابع، خواهیم توانست آن را فراخوانی کنیم. 
بسیاری از دستوراتی را که تابحال از آن‌ها استفاده می‌کردیم، درواقع تابع بودند:

```
> type(32)
<class 'int'>
```

که در این جا نام تابع 
type 
است.

## توابع داخلی 
(Built-in functions)

این‌ها توابعی هستند که توسط سازندگان پایتون تعبیه شده‌اند و برای حل مسائل عمومی 
مورد استفاده قرار می‌گیرند.

نمونه‌ای از این توابع عبارتند از:

```
>>> max('Hello world')
'w'

>>> min('Hello world')
' '

> len('Hello world')
11
```

## توابع تبدیل نوع 
(Type conversion functions)

این‌ها نوع دیگری از توابع داخلی هستند که مقدار یک نوع را به نوعی دیگر تبدیل 
می‌کنند:

```
> int(3.99999)
3

> int(-2.3)
-2

> float('3.14159')
3.14159
```

## توابع ریاضی 
(Math functions)

پایتون دارای یک ماژول ریاضی است که اکثر توابع ریاضی مشهور را ارائه می‌دهد. 
اما قبل از اینکه بتوانیم از ماژول استفاده کنیم، باید آن را وارد 
(import)
کنیم:

```
> import math
```

این عبارت یک شی ماژول به نام 
math 
ایجاد می کند.

برای دسترسی به یکی از توابع، باید نام ماژول و نام تابع را که با یک نقطه 
از هم جدا شده اند (که به عنوان نقطه نیز شناخته می شود) مشخص کنیم.
به این فرمت، علامت نقطه می گویند.

```
> ratio = signal_power / noise_power
> decibels = 10 * math.log10(ratio)
> radians = 0.7
> height = math.sin(radians)
```

## اعداد تصادفی 
(Random numbers)

به نظر می‌رسد که ساختن یک برنامه واقعاً غیر قطعی چندان آسان نیست، اما 
راه‌هایی وجود دارد که حداقل غیرقطعی به نظر برسد. 
یکی از آنها استفاده از الگوریتم‌هایی است که اعداد شبه تصادفی تولید می‌کنند. 
درست است که اعداد شبه تصادفی واقعاْ تصادفی نیستندُ‌اما بازهم تمایز آن‌ها از 
اعداد تصادفیُ غیرممکن است. 

ماژول 
random 
توابعی را بدست می‌دهد که اعداد تصادفی تولید می‌کنند.

یک مثال را باهم ببینیم:

```
import random
for i in range(10):
  x = random.random()
  print(x)
```

این برنامه یک لیستی از اعداد تصادفی بین 
۰.۰ 
و 
۱.۰ 
تولید می‌کند که شامل 
۱.۰ 
نمی‌شوند:

```
0.11132867921152356
0.5950949227890241
0.04820265884996877
0.841003109276478
0.997914947094958
0.04842330803368111
0.7416295948208405
0.510535245390327
0.27447040171978143
0.028511805472785867
```

مثال‌هایی دیگر از توابع 
random‌
عبارتند از: 

```
> random.randint(5, 10)
5

> t = [1, 2, 3]
> random.choice(t)
2
```

## افزودن یک تابع جدید

ما معمولاْ برای پیشبرد اهداف برنامه موردنظرمان، نیاز به تعریف توابع جدید خواهیم داشت. 
این توابع در آینده بارها و بارها می‌توانند مورد استفاده قرار گیرند.

در مثال زیر، یک تابع به نام 
print_lyrics 
تعریف می‌کنیم:

```
def print_lyrics():
  print("I'm a lumberjack, and I'm okay.")
  print('I sleep all night and I work all day.')
```

همانطور که در این مثال می‌بینید، کلمه کلیدی 
def 
برای تعریف تابع بکار برده می‌شود. 
با تعریف یک تابع، یک متغیر با همان نام ایجاد می‌شود. 
نحو فراخوانی تابع جدید مانند توابع داخلی است:

```
> print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
```

ما حتی می‌توانیم یک تابع تعریف شده را درون تابع دیگر، فراخوانی کنیم.

## پارامترها و آرگومان‌ها

برخی از توابع داخلی که دیده‌ایم به آرگومان نیاز دارند. 
برای مثال، وقتی تابع 
math.sin 
را فراخوانی می‌کنیم، باید یک عدد را به آن بدهیم. به این ورودی، آرگومان 
(argument) 
گفته می‌شود.

## توابع دارای خروجی و توابع بدون خروجی
(Fruitful functions and void functions)

در اجرای برخی توابع، با اتمام آخرین دستور تابع، مقداری را به عنوان نتیجه در خروجی 
می‌بینیم 
(fruitful functions).

```
> math.sqrt(5)
2.23606797749979
```

اما این اتفاق برای همه توابع رخ نمی‌دهد. درواقع این توابع کاری را انجام 
داده‌اند که بصورت خروجی قابل نمایش نیست. 
این توابع را 
void function 
می‌نامند:

```
def No_reult_func ():
  x = math.cos(radians)
```

